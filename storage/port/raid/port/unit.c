/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    unit.c

Abstract:

    Implementation of the operations on the logical unit for the RAIDPORT
    driver.

Author:

    Matthew D Hendel (math) 19-Apr-2000

Revision History:

--*/


#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RaUnitPnpIrp)
#pragma alloc_text(PAGE, RaUnitStartDeviceIrp)
#pragma alloc_text(PAGE, RaUnitStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitQueryStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitCancelStopDeviceIrp)
#pragma alloc_text(PAGE, RaUnitRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitQueryRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitCancelRemoveDeviceIrp)
#pragma alloc_text(PAGE, RaUnitSurpriseRemovalIrp)
#pragma alloc_text(PAGE, RaUnitQueryCapabilitiesIrp)
#pragma alloc_text(PAGE, RaUnitQueryPnpDeviceStateIrp)
#pragma alloc_text(PAGE, RaUnitDeviceUsageNotificationIrp)
#pragma alloc_text(PAGE, RaUnitQueryDeviceRelationsIrp)
#pragma alloc_text(PAGE, RaUnitQueryIdIrp)
#pragma alloc_text(PAGE, RaUnitQueryDeviceTextIrp)
#pragma alloc_text(PAGE, RaUnitIgnorePnpIrp)
#pragma alloc_text(PAGE, RaUnitSucceedPnpIrp)
#pragma alloc_text(PAGE, RaUnitUnknownSrb)
#pragma alloc_text(PAGE, RaUnitDeviceControlIrp)
#pragma alloc_text(PAGE, RaUnitScsiGetAddressIoctl)
#pragma alloc_text(PAGE, RaUnitStorageQueryPropertyIoctl)
#pragma alloc_text(PAGE, RaUnitUnknownIoctl)
#pragma alloc_text(PAGE, RaGetUnitStorageDeviceProperty)
#pragma alloc_text(PAGE, RaGetUnitStorageDeviceIdProperty)


#pragma alloc_text(PAGEVRFY, RaidUnitAllocateSrbExtensionPoolVerify)
#pragma alloc_text(PAGEVRFY, RaidUnitFreeSrbExtensionPoolVerify)
#endif // ALLOC_PRAGMA


//
// Globals
//

//
// Chained IO consolidates the free cycle of IO Request N with the allocation
// cycle of IO Request N+1, thus reducing back-to-back free and allocate
// requests.
//

LOGICAL RaidChainedIo = TRUE;


//
// Routines
//

NTSTATUS
RaidCreateUnit(
    IN PRAID_ADAPTER_EXTENSION Adapter,
    OUT PRAID_UNIT_EXTENSION* UnitBuffer
    )
/*++

Routine Description:

    Create a null raid unit object.

Arguments:

    Adapter -

    UnitBuffer -
    
Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PDEVICE_OBJECT DeviceObject;

    ASSERT_ADAPTER (Adapter);
    ASSERT (UnitBuffer != NULL);
    
    PAGED_CODE ();


    Status = IoCreateDevice (Adapter->DeviceObject->DriverObject,
                             sizeof (RAID_UNIT_EXTENSION),
                             NULL, // DeviceName,
                             FILE_DEVICE_MASS_STORAGE,
                             (FILE_AUTOGENERATED_DEVICE_NAME |
                              FILE_DEVICE_SECURE_OPEN),
                             FALSE,
                             &DeviceObject);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    Unit = DeviceObject->DeviceExtension;
    RaidZeroUnit (Unit);
    Unit->Adapter = Adapter;
    Unit->DeviceObject = DeviceObject;

    SET_FLAG (DeviceObject->Flags, DO_DIRECT_IO);
    SET_FLAG (DeviceObject->Flags, DO_BUS_ENUMERATED_DEVICE);

    Unit->DeviceObject->AlignmentRequirement =
            Adapter->DeviceObject->AlignmentRequirement;


    //
    // Since the Unit is the child PDO from the adapter, we never
    // get an AddDevice call. Hence, we start in the stopped state.
    //
    
    Unit->DeviceState = DeviceStateNotPresent;

    //
    // Allocate all resources associated with the logical unit.
    //

    Status = RaidUnitAllocateResources (Unit);

    if (!NT_SUCCESS (Status)) {
        REVIEW();
        return Status;
    }

    //
    // The unit queue is locked until we start the device.
    //
    
    RaidLockUnitQueue (Unit);

    *UnitBuffer = Unit;
    
    return STATUS_SUCCESS;
}


VOID
RaidZeroUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Return a logical unit to a NULL status.

Arguments:

    Unit - Logical unit to NULL.

Return Value:

    None.

--*/
{
    RtlZeroMemory (Unit, sizeof (RAID_UNIT_EXTENSION));
    Unit->ObjectType = RaidUnitObject;
    RaCreateTagList (&Unit->TagList);
    RaidCreateRegion (&Unit->SrbExtensionRegion);
    RaCreatePower (&Unit->Power);
    RaSetSystemPowerState (&Unit->Power, PowerSystemWorking);
    RaSetDevicePowerState (&Unit->Power, PowerDeviceD0);
    StorCreateEventQueue (&Unit->PendingQueue);
    Unit->Address = RaidNullAddress;
    Unit->DefaultTimeout = DEFAULT_IO_TIMEOUT;

    RaidInitializeDeferredItem (&Unit->DeferredList.PauseDevice.Header);
    RaidInitializeDeferredItem (&Unit->DeferredList.ResumeDevice.Header);
    RaidInitializeDeferredItem (&Unit->DeferredList.DeviceBusy.Header);
    RaidInitializeDeferredItem (&Unit->DeferredList.DeviceReady.Header);
}



VOID
RaidStartUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Prepare the logical unit to receive IOs.

Arguments:

    Unit - Logical unit to start.

Return Value:

    None.

NOTE: Explain how this differs from the PNP Start IRP.

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();

    ASSERT_UNIT (Unit);
    ASSERT (Unit->DeviceObject != NULL);

    //
    // Handle any cases where the default queue is not correct.
    //
    
    Status = RaUnitSetQueueDepth(Unit);
    ASSERT (NT_SUCCESS (Status));

    ASSERT (memcmp (&Unit->Address, &RaidNullAddress, sizeof (RaidNullAddress)) != 0);

    //
    // Tell PNP that we're done initializing.
    //
    
    CLEAR_FLAG (Unit->DeviceObject->Flags, DO_DEVICE_INITIALIZING);
}


VOID
RaidDeleteUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine deallocates any resources associated with a RAID Unit
    object, preparing the buffer for reuse. This routine must be called
    for every unit before the unit's memory is deallocated.

Arguments:

    Unit - Unit to be deleted.

Return Value:

    NTSTATUS code.

--*/
{
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    DEVICE_STATE DeviceState;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);


    Status = RaidUnitFreeResources (Unit);
    ASSERT (NT_SUCCESS (Status));

    //
    // We may get further remove requests to the logical unit after we have
    // called IoDeleteDevice. To handle this case, we keep the device state
    // valid, even though the remainder of the device has been reclaimed.
    // If we get an IRP it is ok to access the device extension even if
    // we have previously called IoDeleteDevice. These spurious remove IRPs
    // may be completed in any manner.
    //
    
    DeviceObject = Unit->DeviceObject;
    DeviceState = Unit->DeviceState;

    DbgFillMemory (Unit,
                   sizeof (RAID_UNIT_EXTENSION),
                   DBG_DEALLOCATED_FILL);
    Unit->DeviceState = DeviceState;
    
    IoDeleteDevice (DeviceObject);
    
}



VOID
RaidUnitAssignAddress(
    IN PRAID_UNIT_EXTENSION Unit,
    IN RAID_ADDRESS Address
    )
/*++

Routine Description:

    Assign a logical unit's RAID (SCSI) Address. Addresses CAN be modified
    dynamically, although the user should be careful that all outstanding
    requests are completed before any attempt is made to modify the
    Address.

Arguments:

    Unit - Supplies the logical unit to assign the SCSI address to.

    Address - Supplies the SCSI address to assign.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Verify that there are no outstanding requests on this Unit.
    //

    Unit->Address = Address;
}

VOID
RaidUnitAssignIdentity(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PSTOR_SCSI_IDENTITY Identity
    )
/*++

Routine Description:

    Assign a logical unit's identity. The identity includes the SCSI
    INQUIRY data, plus pages 80 and 80 of the Vital Product Data.

Arguments:

    Unit - Supplies the logical unit whose identity is to be assigned.

    Identity - Supplies a pointer to the identity to be assigned. By
            calling this call, the caller grants ownership of the
            identity data to the logical unit. It must not access this
            buffer after calling this function.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Verify that there are no outstanding requests on this Unit.
    //

    RtlCopyMemory (&Unit->Identity, Identity, sizeof (STOR_SCSI_IDENTITY));
    RtlZeroMemory (Identity, sizeof (STOR_SCSI_IDENTITY));
}



NTSTATUS
RaidUnitAllocateResources(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Allocate all resources necessary for a logical unit to function.

Arguments:

    Unit - Supplies the logical unit to allocate resources for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG NumberOfElements;
    ULONG SrbExtensionSize;
    PVOID SrbExtensionBuffer;
    PHYSICAL_ADDRESS PhysicalAddress;
    LARGE_INTEGER LargeTimeout;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_IO_RESOURCES ResetResources;
    ULONG ResetTag;

    PAGED_CODE();
    
    Adapter = Unit->Adapter;

    //
    // The remove lock is 1-biased.
    //
    
    Unit->OutstandingCount = 1;
    KeInitializeEvent (&Unit->ZeroOutstandingEvent,
                       SynchronizationEvent,
                       FALSE);

    //
    // If verifier is enabled and configured to allocate common buffer space
    // in separate blocks, call out to the verifier routine to do the
    // allocation.
    //
    
    NumberOfElements = TAG_QUEUE_SIZE + 1;
    
    Status = RaidUnitAllocateSrbExtensionPool (Unit,
                                               &NumberOfElements,
                                               TRUE);
    ASSERT (NT_SUCCESS (Status));

    //
    // Xrb lookaside list.
    //

    ExInitializeNPagedLookasideList (&Unit->XrbList,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof (EXTENDED_REQUEST_BLOCK),
                                     XRB_TAG,
                                     0);

    RaInitializeTagList (&Unit->TagList,
                         NumberOfElements,
                         Unit->DeviceObject);

    //
    // Initialize the pending queue.
    //
    
    StorInitializeEventQueue (&Unit->PendingQueue);

    KeInitializeDpc (&Unit->PendingDpc,
                     RaidUnitPendingDpcRoutine,
                     Unit->DeviceObject);

    KeInitializeTimer (&Unit->PendingTimer);

    //
    // Initialize the pause timer.
    //

    KeInitializeTimer (&Unit->PauseTimer);

    KeInitializeDpc (&Unit->PauseTimerDpc,
                     RaidUnitPauseTimerDpcRoutine,
                     Unit->DeviceObject);
   
    //
    // Set timer to fire once per second.
    //

    LargeTimeout.QuadPart = 1;
    LargeTimeout.QuadPart *= SECONDS;
    LargeTimeout.QuadPart *= RELATIVE_TIMEOUT;
    
    KeSetTimerEx (&Unit->PendingTimer,
                  LargeTimeout,
                  1 * 1000,             // milli
                  &Unit->PendingDpc);
    
    KeInitializeSpinLock (&Unit->SlowLock);

    //
    // Initialize an IO_QUEUE for the unit object. We initialize the IO queue
    // to NumberOfElements - 1 so that the final element in the queue can
    // be pre-allocate as a reset resource.
    //
    
    RaidInitializeIoQueue (&Unit->IoQueue,
                           Unit->DeviceObject,
                           &Unit->Adapter->Gateway,
                           RaUnitStartIo,
                           NumberOfElements - 1);
    //
    // Create logical unit extension, if necessary.
    //

    if (Adapter->Miniport.PortConfiguration.SpecificLuExtensionSize) {
        ULONG Size;

        Size = Adapter->Miniport.PortConfiguration.SpecificLuExtensionSize;
        Unit->UnitExtension = RaidAllocatePool (NonPagedPool,
                                                Size,
                                                UNIT_EXT_TAG,
                                                Unit->DeviceObject);
                                                
        if (Unit->UnitExtension == NULL) {
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory (Unit->UnitExtension, Size);
    }


    //
    // Pre-allocate reset resources.
    //

    ResetTag = NumberOfElements - 1;
    ResetTag = RaAllocateSpecificTag (&Unit->TagList, ResetTag);
    ASSERT (ResetTag);

    ResetResources = &Unit->ResetResources;
    ResetResources->QueueTag = ResetTag;
    ResetResources->SrbExtension = RaidAllocateSrbExtension (
                                        &Unit->SrbExtensionPool,
                                        ResetTag);
    ResetResources->Xrb = RaidAllocateXrb (&Unit->XrbList,
                                           Unit->DeviceObject);
    ASSERT (ResetResources->Xrb != NULL);

    return STATUS_SUCCESS;
}


NTSTATUS
RaidUnitAllocateSrbExtensionPool(
    IN PRAID_UNIT_EXTENSION Unit,
    IN OUT PULONG NumberOfElements,
    IN BOOLEAN AcceptLowerCount
    )
/*++

Routine Description:

    Allocate memory for the SRB extension region.

Arguments:

    Unit - Supplies logical unit to allocate memory for.

    NumberOfElements - Supplies the number of elements requested for this
        logical unit. On success, returns the number of elements actually
        allocated.

    AcceptLowerCount - If TRUE, we will accept a lower count of SRB
        extension elements than requested in NumberOfElements. Otherwise,
        we will fail if we were not able to allocate the requested
        number of elements.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG Count;
    ULONG SrbExtensionSize;
    ULONG BufferSize;
    NTSTATUS Status;
    PRAID_ADAPTER_PARAMETERS Parameters;


    PAGED_CODE();

    SrbExtensionSize = RaGetSrbExtensionSize (Unit->Adapter);
    Count = *NumberOfElements;

    //
    // Loop retrying the allocation on lower and lower sizes until we
    // find a size that works.
    //
    // NB: There is a better way to do this. Instead of lowering the count
    // we break the region into smaller sizes. Another way of doing this
    // is to allocate the srb extension pool on the HBA instead of the
    // unit, sharing the SrbExtension Pool. This makes a number of things
    // more difficult.
    //
    
    do {

        //
        // Srb extension pool.
        //
        
        BufferSize = Count * SrbExtensionSize;
        Status = RaidDmaAllocateCommonBuffer (&Unit->Adapter->Dma,
                                              BufferSize,
                                              &Unit->SrbExtensionRegion);

        //
        // Failed the first allocation attempt: try a lower value.
        //
        
        if (Status == STATUS_NO_MEMORY ||
            Status == STATUS_INSUFFICIENT_RESOURCES) {
            Count /= 2;
        }

    } while (AcceptLowerCount &&
             Status == STATUS_NO_MEMORY &&
             Count > 0);

    if (!NT_SUCCESS (Status)) {
        return STATUS_NO_MEMORY;
    }

    RaidInitializeFixedPool (&Unit->SrbExtensionPool,
                             RaidRegionGetVirtualBase (&Unit->SrbExtensionRegion),
                             Count,
                             SrbExtensionSize);

    *NumberOfElements = Count;

    return STATUS_SUCCESS;
}


NTSTATUS
RaidUnitAllocateSrbExtensionPoolVerify(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PULONG NumberOfElements,
    IN LOGICAL AcceptLowerCount
    )
/*++

Routine Description:

    Allocate all resources necessary for a logical unit to function.

Arguments:

    Unit - Supplies the logical unit to allocate resources for.

Return Value:

    NTSTATUS code.

Notes:

    This function is for use by the driver verifier.

    This function needs to be rewritten.

--*/
{
    NTSTATUS Status;
    ULONG BlockSize;
    ULONG i;
    ULONG Length;
    PALLOCATE_COMMON_BUFFER AllocateCommonBuffer;
    IN PRAID_DMA_ADAPTER Dma;
    PVOID Buffer = NULL;
    PRAID_MEMORY_REGION BlkAddr;
    PRAID_FIXED_POOL Pool;
    PVOID *SrbExtension = NULL;
    PHYSICAL_ADDRESS PhysicalAddress;
    PRAID_ADAPTER_EXTENSION Adapter;
    ULONG Count;

    TEXT_SECTION (PAGEVRFY);
    
    Adapter = Unit->Adapter;
    Count = *NumberOfElements;
    ASSERT (Count != 0);
        
    
    //
    // We maintain an array in order to find our common buffer
    // blocks at various times.  
    //

    Length = sizeof(RAID_MEMORY_REGION) * Count;

    BlkAddr = RaidAllocatePool (NonPagedPool,
                                Length,
                                SRB_EXTENSION_TAG,
                                Unit->DeviceObject);

    if (BlkAddr == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (BlkAddr, Length);

    Unit->CommonBufferVAs = BlkAddr;
    Unit->CommonBufferBlocks = Count;

    //
    // Calculate the block size for a SRB extension block.
    //

    BlockSize = (ULONG)ROUND_TO_PAGES(RaGetSrbExtensionSize (Adapter));

    //
    // Add a page for holding bookkeeping information.
    //

    BlockSize += PAGE_SIZE;

    Unit->CommonBufferSize = BlockSize;

    //
    // Allocate each block individually and link them all together into
    // a list.  If we fail to allocate any of the blocks, we clean everything
    // up and return failure.
    //

    Dma = &Unit->Adapter->Dma; 
    ASSERT (Dma != NULL);
    ASSERT (Dma->DmaAdapter->DmaOperations->AllocateCommonBuffer != NULL);

    for (i = 0; i < Count; i++) {

        Buffer = Dma->DmaAdapter->DmaOperations->AllocateCommonBuffer(
                        Dma->DmaAdapter,
                        BlockSize,
                        &PhysicalAddress,
                        FALSE);

        if (Buffer == NULL) {
            break;
        }

        RtlZeroMemory (Buffer, BlockSize);

        //
        // Initialize the region with the proper information.
        //

        RaidInitializeRegion ((BlkAddr + i),
                              Buffer,
                              PhysicalAddress,
                              BlockSize);

        
        //
        // Link the new block onto the front of the chain.
        //

        *((PVOID *)Buffer) = SrbExtension;
        SrbExtension = (PVOID *)Buffer;
    }

    if (!AcceptLowerCount && i < Count) {
        RaidFreePool (Unit->CommonBufferVAs, SRB_EXTENSION_TAG);
        Unit->CommonBufferVAs = NULL;
        Unit->CommonBufferBlocks = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Reset this to the actual count.
    //

    Count = i;
    Unit->CommonBufferBlocks = Count;
        
        

    ASSERT (Buffer != NULL);

    Pool = &Unit->SrbExtensionPool;

    Pool->Buffer = (PUCHAR)SrbExtension;
    Pool->NumberOfElements = Count;
    Pool->SizeOfElement = BlockSize;


    //
    // Create a second VA mapping of the common buffer area so we can make the 
    // range of addresses invalid when the miniport is not supposed to touch
    // it. This will allow us to catch misbehaving miniports.
    //

    RaidRemapCommonBufferForMiniport (Unit);

    return STATUS_SUCCESS;

}


VOID
RaidUnitFreeSrbExtensionPoolVerify(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Release all resources associated with a logical unit.

Arguments:

    Unit - Supplies the logical unit to release resources for.

Return Value:

    NTSTATUS code.

--*/
{
    ULONG i;
    PSP_VA_MAPPING_INFO MappingInfo;
    PRAID_MEMORY_REGION BlkAddr = Unit->CommonBufferVAs;

    TEXT_SECTION (PAGEVRFY);
    
    for (i = 0; i < Unit->CommonBufferBlocks; i++) {

        //
        // If there is a second VA range for the common block, free the
        // MDL(s).
        //

        MappingInfo = GET_VA_MAPPING_INFO(Unit, BlkAddr[i].VirtualBase);

        if (MappingInfo->SrbExtMdl != NULL) {
            MmProtectMdlSystemAddress(MappingInfo->SrbExtMdl, PAGE_READWRITE);
            MmUnlockPages(MappingInfo->SrbExtMdl);
            IoFreeMdl(MappingInfo->SrbExtMdl);
        }

        //
        // Free the memory.
        //


        RaidDmaFreeCommonBuffer (&Unit->Adapter->Dma,
                                (BlkAddr + i));
        RaidDeleteFixedPool (&Unit->SrbExtensionPool);
    }
}


NTSTATUS
RaidUnitFreeResources(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Release all resources associated with a logical unit.

Arguments:

    Unit - Supplies the logical unit to release resources for.

Return Value:

    NTSTATUS code.

--*/
{
    PVOID Buffer;

    PAGED_CODE();
    
    //
    // Free the XRB lookaside list.
    //

    if (Unit->XrbList.L.Size != 0) {
        ExDeleteNPagedLookasideList (&Unit->XrbList);
    }

    //
    // Free the SRB extension region and pool, if necessary.
    //
    
    if (StorIsVerifierEnabled ()) {
    
        RaidUnitFreeSrbExtensionPoolVerify (Unit);
        
    } else {

        if (RaidIsRegionInitialized (&Unit->SrbExtensionRegion)) {
            
            RaidDmaFreeCommonBuffer (&Unit->Adapter->Dma,
                                     &Unit->SrbExtensionRegion);
            RaidDeleteFixedPool (&Unit->SrbExtensionPool);

        }
    }

    StorDeleteEventQueue (&Unit->PendingQueue);
    StorDeleteScsiIdentity (&Unit->Identity);
    RaDeleteTagList (&Unit->TagList);

    if (Unit->UnitExtension != NULL) {
        RaidFreePool (Unit->UnitExtension, UNIT_EXT_TAG);
        Unit->UnitExtension = NULL;
    }

    //
    // Deregister with WMI if we are registered.
    //

    if (Unit->Flags.WmiInitialized == TRUE) {
        IoWMIRegistrationControl(Unit->DeviceObject, WMIREG_ACTION_DEREGISTER);
        Unit->Flags.WmiInitialized = FALSE;
    }

    KeCancelTimer (&Unit->PendingTimer);
    KeCancelTimer (&Unit->PauseTimer);

//    StorDeleteEventQueue (&Unit->PendingQueue);

    return STATUS_SUCCESS;
}



//
// Handler functions.
//

NTSTATUS
RaUnitCreateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (Unit->DeviceState, Irp);
}

NTSTATUS
RaUnitCloseIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidHandleCreateCloseIrp (Unit->DeviceState, Irp);
}

BOOLEAN
RaUnitAllowPnpRequest(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine determines whether to allow the request to be processed 
    when the Unit is being removed.

Arguments:

    Irp - Pnp irp to handle.

Return Value:

    TRUE - If the request should be allowed through.

--*/
{
    ULONG minorFunction;

    //
    // Ensure this is a PnP Irp.
    //
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);
    
     //
     // Extract the IRP_MN_XXX from the Irp.
     //
     minorFunction = RaidMinorFunctionFromIrp(Irp);
     
     //
     // If the request has anything to do with removes, let it through.
     //
     if ((minorFunction == IRP_MN_REMOVE_DEVICE) ||
         (minorFunction == IRP_MN_CANCEL_REMOVE_DEVICE) ||
         (minorFunction == IRP_MN_SURPRISE_REMOVAL)) {
   
         return TRUE;
     }
     return FALSE;
}

NTSTATUS
RaUnitPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the PnP dispatch routine for the Raid Unit object.  It's
    purpose it to forward the irp on to sub-dispatch routines for the
    specific irp.

Arguments:

    Unit - The unit object this irp is for.

    Irp - Pnp irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Minor;
    BOOLEAN RemlockHeld;
    
    PAGED_CODE ();
    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);

    Status = RaUnitAcquireRemoveLock (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, Status);
    } 

    RemlockHeld = TRUE;
    Minor = RaidMinorFunctionFromIrp (Irp);

    DebugPnp (("Unit %p, Irp %p, Pnp, Minor %x\n",
                 Unit,
                 Irp,
                 Minor));

    //
    // Dispatch the IRP to one of our handlers.
    //

    switch (Minor) {

        case IRP_MN_START_DEVICE:
            Status = RaUnitStartDeviceIrp (Unit, Irp);
            break;
        
        case IRP_MN_STOP_DEVICE:
            Status = RaUnitStopDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            Status = RaUnitQueryStopDeviceIrp (Unit, Irp);
            break;
            
        case IRP_MN_CANCEL_STOP_DEVICE:
            Status = RaUnitCancelStopDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
            Status = RaUnitRemoveDeviceIrp (Unit, Irp);
            RemlockHeld = FALSE;
            break;
            
        case IRP_MN_QUERY_REMOVE_DEVICE:
            Status = RaUnitQueryRemoveDeviceIrp (Unit, Irp);
            break;
            
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            Status = RaUnitCancelRemoveDeviceIrp (Unit, Irp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            Status = RaUnitSurpriseRemovalIrp (Unit, Irp);
            RemlockHeld = FALSE;
            break;
            
        case IRP_MN_QUERY_CAPABILITIES:
            Status = RaUnitQueryCapabilitiesIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            Status = RaUnitQueryPnpDeviceStateIrp (Unit, Irp);
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            Status = RaUnitDeviceUsageNotificationIrp (Unit, Irp);
            break;
            
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            Status = RaUnitQueryDeviceRelationsIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_ID:
            Status = RaUnitQueryIdIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_DEVICE_TEXT:
            Status = RaUnitQueryDeviceTextIrp (Unit, Irp);
            break;

        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            Status = RaUnitSucceedPnpIrp(Unit, Irp);
            break;

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
        case IRP_MN_QUERY_BUS_INFORMATION:
        case IRP_MN_QUERY_INTERFACE:
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        default:
            Status = RaUnitIgnorePnpIrp (Unit, Irp);
            break;
    }

    DebugPnp (("Unit %p, Irp %p, Pnp Minor %x, ret = %08x\n",
                 Unit,
                 Irp,
                 Minor,
                 Status));

    if (RemlockHeld) {
        RaUnitReleaseRemoveLock (Unit, Irp);
    }

    return Status;
}


NTSTATUS
RaUnitSetQueueDepth(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine will set the Depth of the IoQueue (and indirectly the ExQueue
    behind it) based on whatever characteristics of Unit that make it such
    that the queue depth should be changed.

    Currently, only tape devices are handled.

Arguments:

    Unit - The device to examine and update it's queue, if applicable. 

Return Value:

    SUCCESS - if the queue was unchanged, or it was updated correctly.

    UNSUCCESSFUL - if an error occurred while updating the queue depth.

--*/
{
    ULONG intendedDepth;
    ULONG depth;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    //
    // The only check for now is whether this is a tape device or not. Others
    // may need to be applied.
    // 

    if (Unit->Identity.InquiryData->DeviceType == SEQUENTIAL_ACCESS_DEVICE) { 

        //
        // Set the Q-Depth to 1, as when a Check Condition occurs any other
        // requests out on the device will be resumed, once the CA is cleared.
        // This can lead to a state where the backup app. gets very confused about
        // the device's position.
        //
        intendedDepth = 1;

        //
        // Set the unit's max depth value, so that the unit can disallow
        // any requests to exceed it. 
        //
        Unit->MaxQueueDepth = 1;

    } else {

        //
        // Start off with a value well below max. This should be realistic for most
        // LUNs.
        // 
        intendedDepth = 20;
        
        //
        // Set the unit's max depth value, so that the unit can disallow
        // any requests to up the depth past the max.
        //
        Unit->MaxQueueDepth = TAG_QUEUE_SIZE;
    }

    //
    // Set the depth.
    // 
    depth = RaidSetIoQueueDepth(&Unit->IoQueue,
                                intendedDepth);


    if (intendedDepth == depth) {

        //
        // Either the depth was successfully set, or no changes were made.
        //
        status = STATUS_SUCCESS;
    }

    return status;
}    

NTSTATUS
RaUnitStartDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit stop device pnp irp.

Arguments:

    Unit - Unit to start.

    Irp - Start device irp.

Return Value:

    NTSTATUS code.

--*/

{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    //
    // Initialize WMI for the Device.
    //
    
    RaUnitInitializeWMI (Unit);

    //
    // Register the DeviceMap entry.
    //
    
    RaidUnitRegisterInterfaces (Unit);

    //
    // Unlock the unit queue.
    //
    
    if (RaidIsUnitQueueLocked (Unit)) {
        RaidUnlockUnitQueue (Unit);
    }

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateWorking);
    ASSERT (PriorState == DeviceStateStopped ||
            PriorState == DeviceStateDisabled);

    return RaidCompleteRequest (Irp, STATUS_SUCCESS);
}

NTSTATUS
RaidUnitRegisterInterfaces(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Registers any device interfaces associated with the logical unit.
    
Arguments:

    Unit - Logical unit.

Return Value:

    NTSTATUS code.

--*/
{
    HANDLE BusKey;
    HANDLE TargetKey;
    NTSTATUS Status;
    RAID_ADDRESS Address;
    PSTOR_SCSI_IDENTITY Identity;
    PVPD_IDENTIFICATION_PAGE DeviceId;
    ULONG DeviceIdLength;

    ASSERT_UNIT (Unit);
    
    PAGED_CODE();

    //
    // The only interface we support for the LUN is the DeviceMap.
    //
    
    Address = Unit->Address;
    BusKey = RaidAdapterGetBusKey (Unit->Adapter, Address.PathId);

    //
    // Build the target entry.
    //
    
    Status = PortMapBuildTargetEntry (BusKey,
                                      Address.TargetId,
                                      &TargetKey);

    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Build the LUN entry.
    //

    Identity = &Unit->Identity;
    DeviceId = Identity->DeviceId;
    if (DeviceId) {
        DeviceIdLength = min (DeviceId->PageLength,
                              sizeof (VPD_IDENTIFICATION_PAGE));
    } else {
        DeviceIdLength = 0;
    }
    
    PortMapBuildLunEntry (TargetKey,
                          Address.Lun,
                          Identity->InquiryData,
                          &Identity->SerialNumber,
                          DeviceId,
                          DeviceIdLength,
                          NULL);

    ZwClose (TargetKey);

    return STATUS_SUCCESS;
}

NTSTATUS
RaidUnitUnRegisterInterfaces(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Unregister any interfaces registered through RaidUnitRegisterInterfaces.
    At this time the DeviceMap interface is the only one we support.

Arguments:

    Unit - Logical unit to unregister interfaces for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG PortNumber;
    RAID_ADDRESS Address;

    PAGED_CODE();

    Address = Unit->Address;
    PortNumber = Unit->Adapter->PortNumber;

    Status = PortMapDeleteLunEntry (PortNumber,
                                    Address.PathId,
                                    Address.TargetId,
                                    Address.Lun);
    return Status;
}
    

NTSTATUS
RaUnitStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit stop device pnp irp.

Arguments:

    Unit - Unit to stop.

    Irp - Stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateStopped);
    ASSERT (PriorState == DeviceStatePendingStop);

    RaidLockUnitQueue (Unit);

    return RaidCompleteRequest (Irp, STATUS_SUCCESS);



}

NTSTATUS
RaUnitQueryStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit query stop device irp.

Arguments:

    Unit - Unit to query for stop.

    Irp - Query stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    //
    // NB: Even if we fail this IRP, we must still enter the PendingStop
    // state because the PnP manager will send us cancel stop after this.
    //
    
    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStatePendingStop);
    ASSERT (PriorState == DeviceStateWorking);
    
    if (Unit->PagingPathCount == 0) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_DEVICE_BUSY;
    }
    
    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitCancelStopDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for unit cancel stop device irp.

Arguments:

    Unit - Unit to cancel stop for.

    Irp - Cancel stop device irp.

Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateWorking);

    //
    // We can receive a cancel stop without having ever receiving a
    // pending stop. This is ok, either way we want to go back to
    // working state.
    //
    
    ASSERT (PriorState == DeviceStatePendingStop ||
            PriorState == DeviceStateWorking);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit remove device irp.

Arguments:

    Unit - Unit to remove.

    Irp - Remove irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    
    PAGED_CODE();

    DebugPnp (("Unit %p, Irp %p, Pnp, Minor: Remove\n",
                  Unit, Irp));

    //
    // According to the DDK it's possible to receive a PNP remove after
    // have already called IoDeleteDevice. In this case, we may complete
    // the additional remove IRP with any status we choose.
    //
    
    if (Unit->DeviceState == DeviceStateDeleted) {
        REVIEW();
        DebugPnp (("Unit %p, Irp %p, Pnp, Minor: Remove - completing IRP in deleted state STATUS_NO_SUCH_DEVICE\n",
                     Unit, Irp));
        return RaidCompleteRequest (Irp, STATUS_NO_SUCH_DEVICE);
    }
    
    if (Unit->Flags.Present) {
        Status = RaUnitDisableDeviceIrp (Unit, Irp);
    } else {
        Status = RaUnitDeleteDeviceIrp (Unit, Irp);
    }

    DebugPnp (("Unit %p, Irp %p, Pnp, Minor: Remove, ret = %08x\n",
                 Unit, Irp, Status));

    return Status;
}

NTSTATUS
RaUnitDisableDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler for an IRP_MN_REMOVE PNP IRP when the IRP is a disable request.
    This is the case when:

     1) We receive a remove and we're in pending remove state.

     2) The device was reported in the last QDR.

     3) The parent FDO was not surprise removed.

    In this case we move to the "disabled" state where requests are failed,
    but resources are not yet deleted. When we get the final request for
    removal, we will delete resources.

    NB: There is not an explicit state for "disabled" in the PNP state machine;
    it must be determined by the PDO itself that we're disabled vs. actually
    removed.

Arguments:

    Unit - Logical unit to be disabled.

    Irp - Irp representing the IRP_MN_REMOVE irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE();

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);
    ASSERT (RaidMinorFunctionFromIrp (Irp) == IRP_MN_REMOVE_DEVICE);
    
    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateDisabled);

    //
    // If there was a claim on this device, there is no more.
    //

    Unit->Flags.DeviceClaimed = FALSE;

    RaUnitReleaseRemoveLock (Unit, Irp);

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);
    

    return RaidCompleteRequest (Irp, Status);
}

NTSTATUS
RaUnitDeleteDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler for IRP_MN_REMOVE_IRP pnp IRP when the irp is a delete request.
    This is the case when it is not a disable IRP (see above).

    This routine will get called in two distinct cases:

     1) child first

     2) parent surprised removed. In this case the child has already been
        removed from the adapter's list and the Adapter field of the Unit
        will be NULL.

Arguments:

    Unit - Logical unit to be deleted.

    Irp - Irp representing the IRP_MN_REMOVE Irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE();

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_PNP);
    ASSERT (RaidMinorFunctionFromIrp (Irp) == IRP_MN_REMOVE_DEVICE);

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateDeleted);

    RaUnitReleaseRemoveLock (Unit, Irp);

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);

    //
    // The Adapter will be NULL when this is a remove IRP following an adapter
    // surprise remove. Otherwise, this will be non-NULL.
    //
        
    if (Unit->Adapter != NULL) {
        RaidAdapterRemoveUnit (Unit->Adapter, Unit);
    } else {

        //
        // Following adapter surprise remove.
        //
        
        REVIEW();
    }

    RaidDeleteUnit (Unit);

    return RaidCompleteRequest (Irp, Status);
}

NTSTATUS
RaUnitQueryRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit query remove device irp.

Arguments:

    Unit - Unit to query remove for.

    Irp - Query remove irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;

    PAGED_CODE ();

    if (Unit->PagingPathCount != 0 ||
        Unit->HiberPathCount  != 0 ||
        Unit->CrashDumpPathCount != 0) {

        Status = STATUS_DEVICE_BUSY;

    } else {
        
        PriorState = StorSetDeviceState (&Unit->DeviceState,
                                         DeviceStatePendingRemove);
        ASSERT (PriorState == DeviceStateWorking ||
                PriorState == DeviceStateStopped ||
                PriorState == DeviceStateDisabled);
        Status = STATUS_SUCCESS;
    }

    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitAdapterRemove(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine is called by the adapter when it receives it's remove
    IRP. In this case, the logical unit needs to go through it's delete
    procedure, since it will not receive another chance to delete itself.

    NB: If the lun is surprise-removed, then it will receive a final remove
    IRP, so it must do nothing here.

Arguments:

    Unit - Unit whose adapter is being removed.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE PriorState;
    
    PAGED_CODE();

    //
    // If the unit has received a surprise remove IRP, it should not delete
    // itself when the adapter is removed. Instead it should wait until
    // it receives it's final remove IRP.
    //
    
    if (Unit->DeviceState == DeviceStateSurpriseRemoval) {
        REVIEW();
        return STATUS_SUCCESS;
    }

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateDeleted);
    ASSERT (PriorState == DeviceStateDisabled);

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);

    RaidDeleteUnit (Unit);

    return STATUS_SUCCESS;
}

NTSTATUS
RaUnitAdapterSurpriseRemove(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine is called by the adapter when it receives it's surprise
    remove IRP. In this case, the logical unit must prepare to be actually
    removed when it receives the next remove IRP. It does this by clearing
    its Present bit (called Missing or ReportedMissing in other drivers) so
    that it gets deleted on the next remove IRP.

Arguments:

    Unit - Logical unit whose parent received the surprise remove IRP.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // We should not get this if we are in the deleted state.
    //
    
    ASSERT (Unit->DeviceState != DeviceStateDeleted);

    //
    // When the parent is surprised removed, we mark the child as
    // not present so that when we receive the child's remove IRP
    // we will interpret it as a delete request.
    //
    
    Unit->Flags.Present = FALSE;

    //
    // NOTE: is it possible for a logical unit to get a remove IRP after a
    // parent has been removed. Therefore, we NULL out the adapter field
    // of the logical unit here, so that when we get the child's remove
    // IRP we will not attempt to access the parent.
    //
    
    Unit->Adapter = NULL;

    //
    // This entry must have been removed from the unit list before calling
    // the surprise remove function.
    //
    
    ASSERT (Unit->NextUnit.Flink == &Unit->NextUnit &&
            Unit->NextUnit.Blink == &Unit->NextUnit);

    ASSERT (Unit->UnitTableLink.Flink == &Unit->UnitTableLink &&
            Unit->UnitTableLink.Blink == &Unit->UnitTableLink);

    return STATUS_SUCCESS;
}
    

NTSTATUS
RaUnitCancelRemoveDeviceIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit remove device irp.

Arguments:

    Unit - Unit to cancel remove device for.

    Irp - Cancel remove device irp.

Return Value:

    NTSTATUS code.

--*/
{
    DEVICE_STATE PriorState;
    
    PAGED_CODE ();

    PriorState = StorSetDeviceState (&Unit->DeviceState, DeviceStateWorking);

    ASSERT (PriorState == DeviceStatePendingRemove ||
            PriorState == DeviceStateWorking);
            
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}


NTSTATUS
RaUnitSurpriseRemovalIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler function for the unit surprise removal irp.

Arguments:

    Unit - Unit to surprise remove.

    Irp - Surprise removal irp.

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS Status;

    PAGED_CODE ();

    //
    // Need to review this path.
    //
    
    StorSetDeviceState (&Unit->DeviceState, DeviceStateSurpriseRemoval);

    //
    // The unit must have been marked as not present if we are being surprise
    // removed.
    //
    
    ASSERT (Unit->Flags.Present == FALSE);

    //
    // Release the reference acquired as a part of entry into dispatch routine.
    //
    
    RaUnitReleaseRemoveLock (Unit, Irp);
    
    //
    // Next, wait for any outstanding requests to be completed.
    //

    Status = RaUnitWaitForRemoveLock (Unit);
    ASSERT (Status == STATUS_SUCCESS);
    
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}
    

NTSTATUS
RaUnitQueryCapabilitiesIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for the query capabilities PnP irp on the unit object.

Arguments:

    Unit - Unit to query.

    Irp - Query capabilities irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    PDEVICE_CAPABILITIES Capabilities;
    PCSCSI_DEVICE_TYPE DeviceType;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    //
    // Setup parameters
    //
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Capabilities = IrpStack->Parameters.DeviceCapabilities.Capabilities;

    Capabilities->RawDeviceOK = 1;
    DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

    //
    // Storage devices install silently.
    //
    
    if (DeviceType->IsStorage) {
        Capabilities->SilentInstall = TRUE;
    }

    Capabilities->Address = StorGetAddressTargetId (Unit->Address);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}



NTSTATUS
RaUnitQueryPnpDeviceStateIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the query device state irp for the logical unit.

Arguments:

    Unit - Unit to handle this irp.

    Irp - Query device state irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    PPNP_DEVICE_STATE DeviceState;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    //
    // Obtain the address for the PNP device state buffer, and update
    // the state.
    //
    
    DeviceState = (PPNP_DEVICE_STATE)&Irp->IoStatus.Information;

    //
    // If the logical unit is on the paging path, tell PNP we can't disable it.
    //
    
    if (Unit->PagingPathCount) {
        SET_FLAG (*DeviceState, PNP_DEVICE_NOT_DISABLEABLE);
    }

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}



NTSTATUS
RaUnitDeviceUsageNotificationIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP MasterIrp
    )
/*++

Routine Description:

    Handle the PnP device usage notification irp.

Arguments:

    Unit - Unit the irp is for.

    MasterIrp - Device usage irp to handle.

Return Value:

    NTSTATUS code.

Comments:

    Look at how pci.sys does this -- it's much cleaner.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION MasterIrpStack;
    PIRP DependentIrp;
    PIO_STACK_LOCATION DependentIrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    Adapter = Unit->Adapter;
    MasterIrpStack = IoGetCurrentIrpStackLocation (MasterIrp);

    DependentIrp = IoAllocateIrp (Adapter->DeviceObject->StackSize + 3, FALSE);

    if (DependentIrp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    //
    // Setup the top level stack location for PNP, DeviceUsageNotification.
    //
    
    DependentIrpStack = IoGetNextIrpStackLocation (DependentIrp);

    //
    // Acquire a remove lock for the dependent IRP.
    //
    
    RaUnitAcquireRemoveLock (Unit, DependentIrp);

    //
    // Setup the dependent IRP.
    //
    
    DependentIrp->Tail.Overlay.Thread = MasterIrp->Tail.Overlay.Thread;
    DependentIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    DependentIrpStack = IoGetNextIrpStackLocation (DependentIrp);
    RtlCopyMemory (DependentIrpStack,
                   MasterIrpStack,
                   sizeof (IO_STACK_LOCATION));

    //
    // We're pending because we're not completing immediately.
    //
    
    IoMarkIrpPending (MasterIrp);
    Status = STATUS_PENDING;

    IoSetCompletionRoutine (DependentIrp,
                            RaUnitDeviceUsageNotificationCompletion,
                            MasterIrp,
                            TRUE,
                            TRUE,
                            TRUE);


    //
    // Pass this down to the Adapter (FDO).
    //
    
    IoCallDriver (Adapter->DeviceObject, DependentIrp);

done:

    return Status;
}


NTSTATUS
RaUnitDeviceUsageNotificationCompletion(
    IN PDEVICE_OBJECT DeviceObject_Do_Not_Use,
    IN PIRP DependentIrp,
    IN PVOID Context
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Do not use. This is often NULL (!?).

    DependentIrp -

    Context - MasterIrp

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIRP MasterIrp;
    PRAID_UNIT_EXTENSION Unit;
    PULONG UsageCount;
    BOOLEAN Increment;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_USAGE_NOTIFICATION_TYPE UsageType;

    //
    // Initialize variables.
    //

    MasterIrp = (PIRP)Context;
    ASSERT (MasterIrp->Type == IO_TYPE_IRP);

    IrpStack = IoGetCurrentIrpStackLocation (MasterIrp);
    Unit = GetUnit (IrpStack->DeviceObject);
    UsageType = IrpStack->Parameters.UsageNotification.Type;
    Increment = IrpStack->Parameters.UsageNotification.InPath;

    
    //
    // If the dependent IRP failed, also fail the master IRP.
    //
    
    if (!NT_SUCCESS (DependentIrp->IoStatus.Status)) {
        Status = DependentIrp->IoStatus.Status;
        goto done;
    }

    //
    // The dependent IRP succeeded, update the master device's path counts,
    // and succeed the master IRP.
    //
    
    switch (UsageType) {

        case DeviceUsageTypePaging:
            UsageCount = &Unit->PagingPathCount;
            break;

        case DeviceUsageTypeHibernation:
            UsageCount = &Unit->HiberPathCount;
            break;

        case DeviceUsageTypeDumpFile:
            UsageCount = &Unit->CrashDumpPathCount;
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
            goto done;
    }

    //
    // Adjust the paging path count and update the device state.
    //
    
    IoAdjustPagingPathCount (UsageCount, Increment);
    IoInvalidateDeviceState (Unit->DeviceObject);
    Status = STATUS_SUCCESS;

done:

    //
    // Finally, release the remove lock and complete the master
    // IRP with the dependent IRP's completion status.
    //

    RaUnitReleaseRemoveLock (Unit, DependentIrp);
    Status = RaidCompleteRequest (MasterIrp,  Status);

    return Status;
}
    

NTSTATUS
RaUnitQueryDeviceRelationsIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle query device relations irp for the unit. The unit only
    supports querying TargetDeviceRelations.

Arguments:

    Unit - Unit to query.

    Irp - Query device relations irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDEVICE_RELATIONS DeviceRelations;
    PIO_STACK_LOCATION IrpStack;
    DEVICE_RELATION_TYPE Type;

    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.QueryDeviceRelations.Type;

    if (Type == TargetDeviceRelation) {
        DeviceRelations = RaidAllocatePool (PagedPool,
                                            sizeof (DEVICE_RELATIONS),
                                            DEVICE_RELATIONS_TAG,
                                            Unit->DeviceObject);

        if (DeviceRelations != NULL) {
            DeviceRelations->Count = 1;
            DeviceRelations->Objects[0] = Unit->DeviceObject;
            ObReferenceObject (Unit->DeviceObject);
            Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NO_MEMORY;
        }
    } else {
        //
        // We must complete the request with it's current status.
        //
        Status = Irp->IoStatus.Status;
    }

    return RaidCompleteRequest (Irp,  Status);
}

NTSTATUS
RaUnitQueryIdIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle query id request for the unit.

Arguments:

    Unit - Unit to handle the request.

    Irp - Query id request to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    BUS_QUERY_ID_TYPE IdType;
    PIO_STACK_LOCATION IrpStack;
    PWSTR Id;
    
    
    PAGED_CODE ();
    ASSERT_UNIT (Unit);
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    IdType = IrpStack->Parameters.QueryId.IdType;
    Id = NULL;
    
    switch (IdType) {

        case BusQueryDeviceID:
            Status = RaidUnitGetDeviceId (Unit, &Id);
            break;

        case BusQueryInstanceID:
            Status = RaidUnitGetInstanceId (Unit, &Id);
            break;

        case BusQueryHardwareIDs:
            Status = RaidUnitGetHardwareIds (Unit, &Id);
            break;

        case BusQueryCompatibleIDs:
            Status = RaidUnitGetCompatibleIds (Unit, &Id);
            break;

        default:
            Status = Irp->IoStatus.Status;
            Id = NULL;
    }

    Irp->IoStatus.Information = (ULONG_PTR) Id;
    return RaidCompleteRequest (Irp,  Status);
}


VOID
DbgPrintIds(
    IN BUS_QUERY_ID_TYPE IdType,
    IN PWSTR Id
    )
{
    ULONG i;
    PWSTR String;
    
    switch (IdType) {

        case BusQueryDeviceID:
            DbgPrint ("STOR: DeviceId: %ws\n", Id);
            break;

        case BusQueryInstanceID:
            DbgPrint ("STOR: InstanceId: %ws\n", Id);
            break;

        case BusQueryHardwareIDs:
            for (String = Id, i=0;
                 String[0] != UNICODE_NULL;
                 String += (wcslen (String) + 1), i++) {

                DbgPrint ("STOR: HardwareId[%d] %ws\n", i, String);
            }
            break;

        case BusQueryCompatibleIDs:
            for (String = Id, i=0;
                 !String[0] != UNICODE_NULL;
                 String += (wcslen (String) + 1), i++) {

                DbgPrint ("STOR: CompatibleId[%d] %ws\n", i, String);
            }
            break;
    }
}

NTSTATUS
RaUnitQueryDeviceTextIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{

    NTSTATUS Status;
    PWCHAR Buffer;
    CHAR VendorId [SCSI_VENDOR_ID_LENGTH + 1];
    CHAR ProductId [SCSI_PRODUCT_ID_LENGTH + 1];
    PCSCSI_DEVICE_TYPE DeviceType;   
    PIO_STACK_LOCATION IrpStack;
    DEVICE_TEXT_TYPE Type;
    
    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Type = IrpStack->Parameters.QueryDeviceText.DeviceTextType;
    
    Buffer = RaidAllocatePool (PagedPool,
                               256 * sizeof (WCHAR),
                               QUERY_TEXT_TAG,
                               Unit->DeviceObject);

    if (Buffer == NULL) {
        return RaidCompleteRequest (Irp,  STATUS_NO_MEMORY);
    }
    
    switch (Type) {

        case DeviceTextDescription:
            //
            // We use "<VENDOR> SCSI <DEVICE-TYPE> Device", like SCSIPORT.
            //

            StorGetIdentityVendorId (&Unit->Identity,
                                     VendorId,
                                     sizeof (VendorId),
                                     TRUE);

            StorGetIdentityProductId (&Unit->Identity,
                                      ProductId,
                                      sizeof (ProductId),
                                      TRUE);

            DeviceType = StorGetIdentityDeviceType (&Unit->Identity);
            swprintf (Buffer,
                      L"%hs %hs SCSI %hs Device",
                      VendorId,
                      ProductId,
                      DeviceType->Name);
                      
            Status = STATUS_SUCCESS;
        break;

        case DeviceTextLocationInformation:
            //
            // We use "Bus Number <PathId>, Target ID <TargetId>, LUN <LUN>",
            // like SCSIPORT.
            //
            swprintf (Buffer,
                      L"Bus Number %d, Target Id %d, LUN %d",
                      Unit->Address.PathId,
                      Unit->Address.TargetId,
                      Unit->Address.Lun);
                      
            Status = STATUS_SUCCESS;
        break;

        default:
            ExFreePool (Buffer);
            Buffer = NULL;
            Status = STATUS_NOT_SUPPORTED;
    }

    Irp->IoStatus.Information = (ULONG_PTR)Buffer;
    return RaidCompleteRequest (Irp,  Status);
}

       
NTSTATUS
RaUnitIgnorePnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp,  Irp->IoStatus.Status);
}
    
NTSTATUS
RaUnitSucceedPnpIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitCheckRemoveStateForDisabled(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    ULONG MajorFunction;
    ULONG MinorFunction;
    UCHAR SrbFunction;

    if (Irp == NULL) {
        return STATUS_DELETE_PENDING;
    }

    MajorFunction = RaidMajorFunctionFromIrp (Irp);
    MinorFunction = RaidMinorFunctionFromIrp (Irp);

    if (MajorFunction == IRP_MJ_SCSI) {
        SrbFunction   = RaidSrbFunctionFromIrp (Irp);
    }

    //
    // If SCSI IRP and special enumeration tag, then allow it through or if
    // SCSI IRP and Claim Device SRB, allow through, else if PNP IRP allow
    // through.
    //
    
    if ((MajorFunction == IRP_MJ_SCSI &&
         MinorFunction == STOR_MN_ENUMERATION_IRP) ||
        (MajorFunction == IRP_MJ_SCSI &&
         SrbFunction == SRB_FUNCTION_CLAIM_DEVICE) ||
        MajorFunction == IRP_MJ_PNP) {

        return STATUS_SUCCESS;
    }

    return STATUS_DELETE_PENDING;
}

NTSTATUS
RaUnitCheckRemoveState(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Check if this IRP can be processed or if it must be failed. This is the
    work-horse routine that is called when acquiring and releasing the
    remove lock.

Arguments:

    Unit - Logical unit to check remove state on.

    Irp - Pointer to the IRP that will be checked.

Return Value:

    STATUS_DELETE_PENDING if the device is being removed or other NTSTATUS
    code.

--*/
{
    NTSTATUS Status;
    DEVICE_STATE DeviceState;
    ULONG MajorFunction;
    ULONG MinorFunction;

    DeviceState = Unit->DeviceState;
    
    //
    // If we're in deleted state, fail, if we're in disabled state, fail
    // unless this is a special port driver enum IRP, otherwise succeed.
    //

    switch (DeviceState) {

        case DeviceStateDeleted:

            Status = STATUS_DELETE_PENDING;
            break;

        case DeviceStateDisabled:

            Status = RaUnitCheckRemoveStateForDisabled (Unit, Irp);
            break;

        default:
            Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
RaUnitAcquireRemoveLock(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Acquire the logical unit's remove lock.

Arguments:

    Unit - Pointer to logical unit extension.

    Irp - Pointer to IO request packet.

Return Value:

    STATUS_DELETE_PENDIG - If the device is being removed.

    STATUS_SUCCESS - If the remove lock was successfully acquired.

--*/
{
    NTSTATUS Status;
    LONG Count;

    //
    // Increment upon entry to avoid race conditions. If we discover that
    // we're in the process of deleting, we'll decrement when exiting.
    //
    
    Count = InterlockedIncrement (&Unit->OutstandingCount);
    ASSERT (Count > 0);

    //
    // Check if this IRP should be allowed to go down.
    //
    
    Status = RaUnitCheckRemoveState (Unit, Irp);

    //
    // If we're removed, decrement the I/O count and set the empty event.
    //
    
    if (!NT_SUCCESS (Status)) {
        Count = InterlockedDecrement (&Unit->OutstandingCount);
        if (Count == 0) {
            KeSetEvent (&Unit->ZeroOutstandingEvent,
                        0,
                        FALSE);
        }
    }
    
    return Status;
}

VOID
RaUnitReleaseRemoveLock(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Release a reference to the remove lock previously acquired in
    RaUnitAcquireRemoveLock.

Arguments:

    Unit - Unit the removelock was acquired on.

    Irp - Irp the remove lock was acquired for. The IRP is used for tracking
        purposes only, and may be an already completed IRP.

Return Value:

    NTSTATUS code.

--*/
{
    LONG Count;

    UNREFERENCED_PARAMETER (Irp);

    Count = InterlockedDecrement (&Unit->OutstandingCount);
    ASSERT (Count >= 0);

    if (Count == 0) {
        KeSetEvent (&Unit->ZeroOutstandingEvent,
                    0,
                    FALSE);
                    
    }
}

NTSTATUS
RaUnitWaitForRemoveLock(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Wait for the remove lock to be freed. 

Arguments:

    Unit - Logical unit the remove lock is on.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    LONG Count;

    PAGED_CODE();

    //
    // The remove lock is 1-biased, so we always decrement it when
    // waiting for it to become free.
    //
    
    Count = InterlockedDecrement (&Unit->OutstandingCount);

    if (Count > 0) {
        Status = StorWaitForSingleObject (&Unit->ZeroOutstandingEvent,
                                          FALSE,
                                          NULL);
    } else {
        ASSERT (Count == 0);
        Status = STATUS_SUCCESS;
    }

    //
    // This restores the remlock count that was removed in waiting for
    // the zero outstanding event to fire, so the remlock is still usable.
    //
    
    InterlockedIncrement (&Unit->OutstandingCount);

    return Status;
}

    

NTSTATUS
RaUnitScsiIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for SCSI irps. 

Arguments:

    Unit - Unit to handle the scsi irp.

    Irp - Scsi irp to handle.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;

    ASSERT (RaidMajorFunctionFromIrp (Irp) == IRP_MJ_SCSI);

    //
    // If the unit is in the process of being removed by Pnp, OR is not
    // physically present, fail the SCSI IRP.
    //
    
    Status = RaUnitAcquireRemoveLock (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,  Status);
    }

    Srb = RaidSrbFromIrp (Irp);

    DebugScsi (("Unit %p, Irp %p, Scsi, SrbFunc %x\n",
                 Unit,
                 Irp,
                 Srb->Function));
                    
    switch (Srb->Function) {

        case SRB_FUNCTION_EXECUTE_SCSI:
            Status = RaUnitExecuteScsiSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_CLAIM_DEVICE:
            Status = RaUnitClaimDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_DEVICE:
            Status = RaUnitReleaseDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_BUS:
            Status = RaUnitResetBusSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_FLUSH_QUEUE:
            Status = RaUnitFlushQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RELEASE_QUEUE: 
            Status = RaUnitReleaseQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_LOCK_QUEUE:
            Status = RaUnitLockQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_UNLOCK_QUEUE:
            Status = RaUnitUnlockQueueSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_FLUSH:
            Status = RaUnitFlushSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_SHUTDOWN:
            Status = RaUnitShutdownSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_IO_CONTROL:
            Status = RaUnitIoControlSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_WMI:
            Status = RaUnitWmiSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_LOGICAL_UNIT:
            Status = RaidUnitResetLogicalUnit (Unit, Irp);
            break;

        case SRB_FUNCTION_RESET_DEVICE:
            Status = RaUnitResetDeviceSrb (Unit, Irp);
            break;

        case SRB_FUNCTION_ATTACH_DEVICE:
        case SRB_FUNCTION_RECEIVE_EVENT:
        case SRB_FUNCTION_ABORT_COMMAND:
        case SRB_FUNCTION_RELEASE_RECOVERY:
        case SRB_FUNCTION_TERMINATE_IO:
        case SRB_FUNCTION_REMOVE_DEVICE:
        default:
            Status = RaUnitUnknownSrb (Unit, Irp);

    }

    DebugScsi (("Unit %p, Irp %p, Scsi, ret = %08x\n",
                 Unit,
                 Irp,
                 Status));

    RaUnitReleaseRemoveLock (Unit, Irp);

    return Status;
}


NTSTATUS
RaidUnitSubmitRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Submit a request to the miniport through the queuing mechanism.

Arguments:

    Unit - Pointer of logical unit that request will be submitted to.

    Irp - Pointer to the request to be submitted.
    
Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Flags;
    PSCSI_REQUEST_BLOCK Srb;

    Srb = RaidSrbFromIrp (Irp);
    IoMarkIrpPending (Irp);
    RaidSrbMarkPending (Srb);

    //
    // We only expect two kinds of SRBs to be send down.
    //
    
    ASSERT (Srb->Function == SRB_FUNCTION_EXECUTE_SCSI ||
            Srb->Function == SRB_FUNCTION_IO_CONTROL ||
            Srb->Function == SRB_FUNCTION_RESET_LOGICAL_UNIT ||
            Srb->Function == SRB_FUNCTION_RESET_DEVICE ||
            Srb->Function == SRB_FUNCTION_RESET_BUS ||
            Srb->Function == SRB_FUNCTION_FLUSH ||
            Srb->Function == SRB_FUNCTION_SHUTDOWN);

    DbgLogRequest (LogSubmitRequest,
                   Irp,
                   (PVOID)(ULONG_PTR)StorScsiAddressToLong (Unit->Address),
                   NULL,
                   NULL);
    Flags = 0;

    //
    // Check for bypass requests.
    //
    
    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE) ||
        TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {
        Flags |= EXQ_BYPASS_REQUEST;
    }

    //
    // If this is a solitary request, set the solitary request flag.
    //
    
    if (IsSolitaryRequest (Srb)) {
        Flags |= EXQ_SOLITARY_REQUEST;
    }


    RaidStartIoPacket (&Unit->IoQueue,
                       Irp,
                       Flags,
                       NULL,
                       NULL);

    Status = STATUS_PENDING;
    return Status;
}


NTSTATUS
RaidUnitSubmitResetRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Submit a request that will allocate reset resources. Thus, this request
    is submitted directly to StartIo instead of potentially queuing the
    request.

Arguments:

    Unit - Logical unit that request will be sent to.

    Irp - Irp to be submitted.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    KIRQL Irql;
    RAID_IO_RESOURCES IoResources;
    PSCSI_REQUEST_BLOCK Srb;

    Srb = RaidSrbFromIrp (Irp);
    IoMarkIrpPending (Irp);
    RaidSrbMarkPending (Srb);

    //
    // Allocate resources for this request.
    //
    
    Status = RaUnitAllocateResetIoResources (Unit, &IoResources);

    //
    // Failure: complete the request and exit the routine.
    //
    
    if (!NT_SUCCESS (Status)) {
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp, Status);
    }

    DbgLogRequest (LogSubmitRequest,
                   Irp,
                   (PVOID)(ULONG_PTR)StorScsiAddressToLong (Unit->Address),
                   NULL,
                   NULL);

    KeRaiseIrql (DISPATCH_LEVEL, &Irql);
    
    RaUnitStartResetIo (Unit->DeviceObject,
                        Irp,
                        &IoResources);

    KeLowerIrql (Irql);
    
    Status = STATUS_PENDING;

    return Status;
}


NTSTATUS
RaUnitExecuteScsiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the SRB_FUNCTION_EXECUTE_SCSI command by queuing the request
    on the LUN queue.

Arguments:

    Unit - Unit to execute the srb on.

    Irp - Irp to execute.

Return Value:

    STATUS_PENDING - On success.

    Other NTSTATUS code - On failure.

    NB: STATUS_SUCCESS should NEVER be returned from this function.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    return RaidUnitSubmitRequest (Unit, Irp);
}

NTSTATUS
RaUnitResetBusSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle a SRB_FUNCTION_RESET_BUS srb. This is done by submitting the
    request to the miniport.

Arguments:

    Unit - Unit the bus reset request is for.

    Irp - Irp representing a bus-reset command.

Return Value:

    NTSTATUS code.

--*/
{
    RaidPauseAdapterQueue (Unit->Adapter);
    return RaidUnitSubmitResetRequest (Unit, Irp);
}


NTSTATUS
RaUnitResetDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle a SRB_FUNCTION_RESET_DEVICE srb. This is done by submitting the
    request to the miniport.

Arguments:

    Unit - Unit the bus reset request is for.

    Irp - Irp representing a reset-device command.

Return Value:

    NTSTATUS code.

--*/
{
    RaidPauseAdapterQueue (Unit->Adapter);
    return RaidUnitSubmitResetRequest (Unit, Irp);
}


NTSTATUS
RaidUnitResetLogicalUnit(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle a SRB_FUNCTION_RESET_LOGICAL_UNIT srb. This is done by submitting
    the request to the miniport.

Arguments:

    Unit - Unit the bus reset request is for.

    Irp - Irp representing a reset-logicical-unit command.

Return Value:

    NTSTATUS code.

--*/
{
    RaidPauseUnitQueue (Unit);
    return RaidUnitSubmitResetRequest (Unit, Irp);
}


NTSTATUS
RaidUnitAllocateIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    )
/*++

Routine Description:

    Allocate a block of IO resources for an I/O.

Arguments:

    Unit - Logical unit on which to allocate resources.

    IoResources - Block of allocated IoResources.

Return Value:

    NTSTATUS code.

--*/
{
    RtlZeroMemory (IoResources, sizeof (RAID_IO_RESOURCES));
    
    //
    // In the current driver architecture, the allocation of the QueueTag
    // can never fail. So don't bother to check for failure.
    //
    
    IoResources->QueueTag = RaAllocateTag (&Unit->TagList);
    ASSERT (IoResources->QueueTag != -1);

    //
    // When the queue tag is allocated, the srb extension slot is reserved.
    // Therefore, the srb extension allocation also cannot fail.
    //
    IoResources->SrbExtension =
        RaidAllocateSrbExtension (&Unit->SrbExtensionPool,
                                  IoResources->QueueTag);
    
    ASSERT (IoResources->SrbExtension != NULL);

    //
    // PERF NOTE: RaidAllocateXrb uses a lookaside list for allocations
    // which locks the bus. We could remove the bus lock by using
    // a fixed pool instead of a lookaside list and not locking at all.
    //

    IoResources->Xrb = RaidAllocateXrb (&Unit->XrbList,
                                        Unit->DeviceObject);
    ASSERT (IoResources->Xrb != NULL);

    return STATUS_SUCCESS;
}


NTSTATUS
RaUnitAllocateResetIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    )
/*++

Routine Description:

    Allocate dynamic resources.

Arguments:

    Unit - Pointer to logical unit that resources will be allocated on.

    IoResources - Supplies buffer where resources will be copied upon success.

Return Value:

    NTSTATUS code.

--*/
{
    LONG Acquired;

    Acquired = InterlockedCompareExchange (&Unit->ResetResourcesAcquired,
                                           1,
                                           0);

    if (Acquired != 0) {

        //
        // A reset is already in progress.
        //
        
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory (IoResources,
                   &Unit->ResetResources,
                   sizeof (RAID_IO_RESOURCES));

    return STATUS_SUCCESS;
}

VOID
RaUnitFreeResetIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    OUT PRAID_IO_RESOURCES IoResources
    )
/*++

Routine Description:

    Free the reset resources previously allocated in RaUnitAllocateResetResources.

Arguments:

    Unit - Logical unit to free the reset resources to.

    IoResources - Reset resources to be freed.
    

Return Value:

    None.

--*/
{
    ASSERT (Unit->ResetResourcesAcquired == 1);
    Unit->ResetResourcesAcquired = 0;

    ASSERT (IoResources->QueueTag == Unit->ResetResources.QueueTag);
}


VOID
RaidUnitFreeIoResources(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PRAID_IO_RESOURCES IoResources
    )
/*++

Routine Description:

    Free IoResources allocated by RaidUnitAllocateIoResources or
    RaidUnitAllocateDynamicIoResources.

Arguments:

    Unit - Logical unit on which resources should be freed.

    IoResources - Pointer to IoResource block to free.

Return Value:

    None.

--*/
{

    VERIFY_DISPATCH_LEVEL();

    RaidFreeSrbExtension (&Unit->SrbExtensionPool, IoResources->QueueTag);
    
    //
    // Free the queue tag.
    //

    RaFreeTag (&Unit->TagList, IoResources->QueueTag);

    //
    // Free the XRB.
    //
    
    RaidFreeXrb (IoResources->Xrb, TRUE);

    DbgFillMemory (IoResources,
                   sizeof (RAID_IO_RESOURCES),
                   DBG_DEALLOCATED_FILL);
}



NTSTATUS
RaidUnitClaimIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp,
    IN PRAID_IO_RESOURCES IoResources OPTIONAL
    )
/*++

Routine Description:

    This routine will allocate any resources necessary to accomplish the
    IO for this specific IRP. At this point, these resources are generally
    SRB resources: queue tag, srb extension, Xrb.

    After an IRP is claimed, it must be released using RaidUnitReleaseIrp.

    This function is only necessary for IRP_MJ_SCSI IRPs.
    
Arguments:

    Unit - Specifies a unit that this SRB should be claimed by.

    Irp - Specifies an IRP to claim.

    IoResources - Preallocated resources to use for this IO.

Return Value:

    NTSTATUS code.

Note:

    This function is generally called from the unit's StartIo routine.

--*/
{
    NTSTATUS Status;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PSCSI_REQUEST_BLOCK Srb;
    RAID_IO_RESOURCES IoResourcesBuffer;
        

    Srb = RaidSrbFromIrp (Irp);
    ASSERT (Srb != NULL);

    //
    // Each irp maintains a reference on the remove lock while being
    // processed. If this lock cannot be acquired, it means we are
    // in the process of being removed, so return status to fail
    // the irp.
    //
    
    Status = RaUnitAcquireRemoveLock (Unit, Irp);
    if (!NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // If we weren't given any resources, allocate necessary resources.
    // Otherwise, we'll reuse the resources from the previous IRP.
    //
    
    if (IoResources == NULL) {
        IoResources = &IoResourcesBuffer;
        Status = RaidUnitAllocateIoResources (Unit, IoResources);
    }

    //
    // If we failed to allocate resources, return failure.
    //
    
    if (!NT_SUCCESS (Status)) {
        RaUnitReleaseRemoveLock (Unit, Irp);
        return Status;
    }

    //
    // Quick check that the allocated IoResources is valid.
    //
    
    ASSERT (IoResources != NULL);
    ASSERT (IoResources->Xrb != NULL);
    ASSERT (IoResources->SrbExtension != NULL);
    
    //
    // Fill in the SCSI target information.
    //

    Srb->TargetId = Unit->Address.TargetId;
    Srb->PathId = Unit->Address.PathId;
    Srb->Lun = Unit->Address.Lun;
    Srb->QueueTag = (UCHAR)IoResources->QueueTag;

    //
    // Fill in Xrb fields.
    //

    Xrb = IoResources->Xrb;
    Xrb->Irp = Irp;
    Xrb->Srb = Srb;
    Xrb->Unit = Unit;
    Xrb->Mdl = Irp->MdlAddress;

    //
    // Set the XRB state to port-processing.
    //
    
    RaidSetXrbState (Xrb, XrbPortProcessing);
    
    //
    // Save SRB fields that we may modify.
    //
    
    Xrb->SrbData.OriginalRequest = Srb->OriginalRequest;
    Xrb->SrbData.DataBuffer = Srb->DataBuffer;

    //
    // Link the Srb to the Xrb and backlink the Xrb to the Srb.
    //
    
    Srb->OriginalRequest = Xrb;

    //
    // Set the Srb extension.
    //

    Srb->SrbExtension = IoResources->SrbExtension;

    //
    // Perform any buffer mapping that may be necessary.
    //
    
    RaidAdapterMapBuffers (Unit->Adapter, Irp);

    //
    // Add the IRP to the unit pending list.
    //
    
    RaUnitAddToPendingList (Unit, Irp);
    
    return STATUS_SUCCESS;
}


VOID
RaidUnitReleaseIrp(
    IN PIRP Irp,
    OUT PRAID_IO_RESOURCES IoResources OPTIONAL
    )
/*++

Routine Description:

    Undo any modifications to the IRP and SRB that were done by
    RaidUnitClaimIrp.

    This function is generally called from the Dpc routine before the
    IRP has been completed.

Arguments:

    Irp - Irp to release.

    IoResources - Buffer to return resources.

Return Value:

    None.

--*/
{
    PRAID_UNIT_EXTENSION Unit;
    PSCSI_REQUEST_BLOCK Srb;
    PEXTENDED_REQUEST_BLOCK Xrb;
    BOOLEAN FreeResources;
    RAID_IO_RESOURCES IoResourcesBuffer;

    VERIFY_DISPATCH_LEVEL();

    Srb = RaidSrbFromIrp (Irp);
    Xrb = RaidGetAssociatedXrb (Srb);
    Unit = Xrb->Unit;
    ASSERT_UNIT (Unit);

    //
    // First, remove the irp from the pending list.
    //
    
    RaUnitRemoveFromPendingList (Unit, Irp);

    //
    // If we were passed in NULL for IoResources parameter, free the
    // associated resources. Otherwise, return the resources in the
    // IoResources parameter.
    //
    
    if (IoResources == NULL) {
        IoResources = &IoResourcesBuffer;
        FreeResources = TRUE;
    } else {
        FreeResources = FALSE;
    }

    //
    // Note the resources that may need to be freed.
    //
    
    IoResources->QueueTag = Srb->QueueTag;
    IoResources->SrbExtension = Srb->SrbExtension;
    IoResources->Xrb = Xrb;

    //
    // Undo any modifications we made to the srb.
    //

    Srb->OriginalRequest = Xrb->SrbData.OriginalRequest;
    Srb->DataBuffer = Xrb->SrbData.DataBuffer;
    Srb->SrbExtension = NULL;

    RaidPrepareXrbForReuse (Xrb, TRUE);

    if (FreeResources) {
        RaidUnitFreeIoResources (Unit, IoResources);
        RtlZeroMemory (IoResources, sizeof (RAID_IO_RESOURCES));
    }

    //
    // The request maintains a reference to the remove lock while being
    // processed. Release it here.
    //
    
    RaUnitReleaseRemoveLock (Unit, Irp);
}


VOID
FORCEINLINE
RaidUnitCompleteRequestHook(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    PSCSI_REQUEST_BLOCK Srb;

    Srb = Xrb->Srb;
    
    switch (Srb->Function) {

        case SRB_FUNCTION_RESET_LOGICAL_UNIT:
            InterlockedDecrement (&Unit->ResetCount);
            RaidResumeUnitQueue (Unit);
            RaidUnitRestartQueue (Unit);
            break;
            
        case SRB_FUNCTION_RESET_BUS:
        case SRB_FUNCTION_RESET_DEVICE:
            InterlockedDecrement (&Unit->ResetCount);
            RaidResumeAdapterQueue (Unit->Adapter);
            RaidAdapterRestartQueues (Unit->Adapter);
            break;
    }
}

VOID
RaidUnitCompleteRequest(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine is called by the adapter's DPC routine after an
    asynchronous IO has completed. It needs to complete the underlying
    IRP and deallocate any resources associated with the IRP.

Arguments:

    Xrb - Xrb to be completed.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL only.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_UNIT_EXTENSION Unit;
    BOOLEAN RestartQueues;
    LOGICAL Started;
    RAID_IO_RESOURCES IoResources;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    Unit = Xrb->Unit;

    ASSERT (Irp != NULL);
    ASSERT (Srb != NULL);
    ASSERT_UNIT (Unit);


    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_SUCCESS) {

        //
        // The IO was successful. Mark the IRP as successful, release
        // resources associated with the IRP and complete the request.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = Srb->DataTransferLength;

        //
        // Release any resources owned by this IRP/SRB, and fixup
        // any modifications we made to the SRB.
        //

        if (RaidChainedIo) {
            RaidUnitReleaseIrp (Irp, &IoResources);
        } else {
            RaidUnitReleaseIrp (Irp, NULL);
        }

        //
        // Complete the request
        //

        DebugScsi (("Unit %p, Irp %p, completing = %08x\n",
                     Unit,
                     Irp,
                     Irp->IoStatus.Status));

        
        DbgLogRequest (LogRequestComplete,
                       Irp,
                       (PVOID)(ULONG_PTR)(Irp->IoStatus.Status),
                       (PVOID)(ULONG_PTR)(Srb->SrbStatus),
                       NULL);

        RaidCompleteRequestEx (Irp,
                               IO_DISK_INCREMENT,
                               Irp->IoStatus.Status);

        //
        // Start the next io packet.
        //

        if (RaidChainedIo) {
            Started = RaidStartNextIoPacket (&Unit->IoQueue,
                                             FALSE,
                                             &IoResources,
                                             &RestartQueues);
            if (!Started) {
                RaidUnitFreeIoResources (Unit, &IoResources);
            }
        } else {
            RaidStartNextIoPacket (&Unit->IoQueue,
                                   FALSE,
                                   NULL,
                                   &RestartQueues);
        }

        if (RestartQueues) {
            RaidAdapterRestartQueues (Unit->Adapter);
        }
        
    } else {

        //
        // Error: Leave all the detail of handling the error, including
        // whether the IRP should be released and completed or not, to
        // the error handling routine.
        //
           
        RaUnitAsyncError (Unit, Xrb);
    }

}


VOID
FORCEINLINE
RaidUnitIssueRequestHook(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
{
    PSCSI_REQUEST_BLOCK Srb;

    Srb = Xrb->Srb;
    
    switch (Srb->Function) {

        case SRB_FUNCTION_RESET_BUS:
        case SRB_FUNCTION_RESET_DEVICE:
        case SRB_FUNCTION_RESET_LOGICAL_UNIT:
            InterlockedIncrement (&Unit->ResetCount);
            break;
    }
}



VOID
RaUnitStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context OPTIONAL
    )
/*++

Routine Description:

    Start the next irp on the specified logical unit.

Arguments:

    DeviceObject - DeviceObject associated with the logical unit
            to start the next irp on.

    Irp - Irp to execute.

    Context - Optional context for this call.

Return Value:

    None. All errors will be handled asynchronously in the DPC routine.

Environment:

    Called from DISPATCH_LEVEL only.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PRAID_ADAPTER_EXTENSION Adapter;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_IO_RESOURCES IoResources;

    VERIFY_DISPATCH_LEVEL();
    
    Unit = (PRAID_UNIT_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);
    Adapter = Unit->Adapter;
    ASSERT_ADAPTER (Adapter);
    IoResources = (PRAID_IO_RESOURCES)Context;

    Srb = RaidSrbFromIrp (Irp);

    //
    // Check if the device has been removed; if it has, fail the request
    // here. This is important because routines can issue I/O without going
    // through the normal Scsi processing. During busy processing, for example,
    // this happens. The call below is equivalent to acquiring and removing
    // the removelock for the given IRP.
    //
    
    Status = RaUnitCheckRemoveState (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        RaidUnitFreeIoResources (Unit, IoResources);
        DebugScsi (("Unit %p, Irp %p, completing %08x\n",
                     Unit->DeviceObject, Irp, Irp->IoStatus.Status));
        RaidCompleteRequest (Irp, Status);
        return;
    }
    
    //
    // Process any items on the deferred queue. This will force any
    // freeze requests to happen here, without waiting for a DPC
    // to be scheduled.
    //

    RaidAdapterProcessDeferredItems (Adapter);

    //
    // Allocate any resources necessary, and modify the associated SRB
    // to be for this LU.
    //

    Status = RaidUnitClaimIrp (Unit, Irp, (PRAID_IO_RESOURCES)Context);

    if (!NT_SUCCESS (Status)) {
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        Irp->IoStatus.Information = 0;
        RaidUnitFreeIoResources (Unit, IoResources);
        DebugScsi (("Unit %p, Irp %p, completing %08x\n",
                     Unit->DeviceObject, Irp, Irp->IoStatus.Status));
        RaidCompleteRequest (Irp,  Status);
        return;
    }

    //
    // The IoResource are now associated with the IRP; NULL out the pointer
    // so we don't accidentially use them.
    //
    
    IoResources = NULL;

    //
    // If the link is down, fail all requests except those associated with
    // bus enumeration.
    //

    if (Unit->Adapter->LinkUp == FALSE) {
        if (Srb->Cdb[0] != SCSIOP_INQUIRY && 
            Srb->Cdb[0] != SCSIOP_REPORT_LUNS) {
            Srb->SrbStatus = SRB_STATUS_LINK_DOWN;
            Irp->IoStatus.Information = 0;
            Status = STATUS_NO_SUCH_DEVICE;
            DebugScsi (("Unit %p, Irp %p, completing %08x b/c link is down\n",
                         Unit->DeviceObject, Irp));
            RaidUnitReleaseIrp (Irp, NULL);
            RaidCompleteRequest (Irp,  Status);
            return;
        }
    }

    //
    // Get associated Xrb.
    //

    Xrb = RaidXrbFromIrp (Irp);

    //
    // Allow any request specific processing to happen, if necessary.
    //
    
    RaidUnitIssueRequestHook (Unit, Xrb);

    //
    // Set a completion routine for the Xrb.
    //

    RaidXrbSetCompletionRoutine (Xrb, RaidUnitCompleteRequest);
    
    //
    // Issue the Execute request to the adapter.
    //

    Status = RaidAdapterExecuteXrb (Unit->Adapter, Xrb);

    if (NT_SUCCESS (Status)) {

        //
        // Remove any further items from the deferred queue. These
        // could have been queued during the processing of the XRB.
        //

        RaidAdapterProcessDeferredItems (Unit->Adapter);
    
    } else {

        //
        // This means we weren't even able to submit the request to the
        // miniport. There's nothing to do but fail the request.
        //

        Srb = RaidSrbFromIrp (Irp);
        RaidUnitReleaseIrp (Irp, NULL);
        Irp->IoStatus.Information = 0;
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        RaidCompleteRequest (Irp, Status);
    }
}


VOID
RaUnitStartResetIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    Start the next irp on the specified logical unit.

Arguments:

    DeviceObject - DeviceObject associated with the logical unit
            to start the next irp on.

    Irp - Irp to execute.

    Context - Optional context for this call.

Return Value:

    None. All errors will be handled asynchronously in the DPC routine.

Environment:

    Called from DISPATCH_LEVEL only.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PEXTENDED_REQUEST_BLOCK Xrb;
    PRAID_ADAPTER_EXTENSION Adapter;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_IO_RESOURCES IoResources;
    LOGICAL IrpClaimed;

    VERIFY_DISPATCH_LEVEL();
    
    Unit = (PRAID_UNIT_EXTENSION)DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);
    Adapter = Unit->Adapter;
    ASSERT_ADAPTER (Adapter);
    IoResources = (PRAID_IO_RESOURCES)Context;
    ASSERT (IoResources != NULL);

    Srb = RaidSrbFromIrp (Irp);
    IrpClaimed = FALSE;

    //
    // Check if the device has been removed; if it has, fail the request
    // here. This is important because routines can issue I/O without going
    // through the normal Scsi processing. During busy processing, for example,
    // this happens. The call below is equivalent to acquiring and removing
    // the removelock for the given IRP.
    //
    
    Status = RaUnitCheckRemoveState (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }
    
    //
    // Allocate any resources necessary, and modify the associated SRB
    // to be for this LU.
    //

    Status = RaidUnitClaimIrp (Unit, Irp, (PRAID_IO_RESOURCES)Context);

    if (!NT_SUCCESS (Status)) {
        goto done;
    }

    //
    // The IoResource are now associated with the IRP; NULL out the pointer
    // so we don't accidentially use them. Also, this tells the failure
    // code at the end of the function to use RaidReleaseIrp instead of
    // RaidUnitFreeIoResources to cleanup after the request.
    //
    
    IoResources = NULL;

    //
    // Increment the reset count. (Maybe with the reset resources, this
    // could be unnecessary.)
    //
    
    InterlockedIncrement (&Unit->ResetCount);

    //
    // Get associated Xrb.
    //

    Xrb = RaidXrbFromIrp (Irp);

    //
    // Set a completion routine for the Xrb.
    //

    RaidXrbSetCompletionRoutine (Xrb, RaidUnitCompleteResetRequest);
    
    //
    // Issue the Execute request to the adapter.
    //

    Status = RaidAdapterExecuteXrb (Unit->Adapter, Xrb);

done:

    //
    // If we failed, cleanup the resources and complete the request.
    //

    if (!NT_SUCCESS (Status)) {
        if (IoResources) {
            RaidUnitFreeIoResources (Unit, IoResources);
        } else {
            RaidUnitReleaseIrp (Irp, NULL);
        }
        Irp->IoStatus.Information = 0;
        Srb->SrbStatus = RaidNtStatusToSrbStatus (Status);
        DebugScsi (("Unit %p, Irp %p, completing %08x\n",
                     Unit->DeviceObject, Irp, Irp->IoStatus.Status));
        RaidCompleteRequest (Irp,  Status);
    }
}


VOID
RaidUnitCompleteResetRequest(
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:


Arguments:

    Xrb - Xrb to be completed.

Return Value:

    None.

Environment:

    DISPATCH_LEVEL only.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PRAID_UNIT_EXTENSION Unit;
    BOOLEAN RestartQueues;
    LOGICAL Started;
    RAID_IO_RESOURCES IoResources;

    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    Unit = Xrb->Unit;

    ASSERT (Irp != NULL);
    ASSERT (Srb != NULL);
    ASSERT_UNIT (Unit);

    RaidUnitCompleteRequestHook (Unit, Xrb);
    
    //
    // The IO was successful. Mark the IRP as successful, release
    // resources associated with the IRP and complete the request.
    //

    Irp->IoStatus.Status = RaidSrbStatusToNtStatus (Srb->SrbStatus);
    Irp->IoStatus.Information = Srb->DataTransferLength;

    //
    // Remove the IRP/SRB/XRB from storport's lists. Have ReleaseIrp
    // return the resources to us so we can free them separately.
    //

    RaidUnitReleaseIrp (Irp, &IoResources);

    //
    // RaidUnitReleaseIrp must have returned the correct I/O resources
    // that cooresponds to the reset resources.
    //
    
    ASSERT (RaUnitIsResetResources (Unit, &IoResources));
    RaUnitFreeResetIoResources (Unit, &IoResources);

    //
    // Complete the request
    //

    DebugScsi (("Unit %p, Irp %p, completing = %08x\n",
                 Unit,
                 Irp,
                 Irp->IoStatus.Status));

    
    DbgLogRequest (LogRequestComplete,
                   Irp,
                   (PVOID)(ULONG_PTR)(Irp->IoStatus.Status),
                   (PVOID)(ULONG_PTR)(Srb->SrbStatus),
                   NULL);

    RaidCompleteRequest (Irp,
                         Irp->IoStatus.Status);

}


NTSTATUS
RaUnitClaimDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    If the device is unclaimed, claim it, otherwise return STATUS_DEVICE_BUSY
    as an error.

Arguments:

    Unit - The unit to claim.

    Irp - The irp representing the claim device irp.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    KLOCK_QUEUE_HANDLE LockHandle;
    PSCSI_REQUEST_BLOCK Srb;
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    Srb = RaidSrbFromIrp (Irp);
    if (!Unit->Flags.DeviceClaimed) {
        Unit->Flags.DeviceClaimed = TRUE;
        //
        // Though this seems wrong, it's what SCSIPORT does. Should
        // clarify the interface.
        //
        Srb->DataBuffer = Unit->DeviceObject;
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
        Status = STATUS_SUCCESS;
    } else {
        Srb->DataBuffer = NULL;
        Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        Srb->InternalStatus = STATUS_DEVICE_BUSY;
        Status = STATUS_DEVICE_BUSY;
    }

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return RaidCompleteRequest (Irp, Status);
}


NTSTATUS
RaUnitReleaseDeviceSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Release the claim on this unit.

Arguments:

    Unit - The unit which must have been claimed.

    Irp - The release device irp.
    
Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    Srb = RaidSrbFromIrp (Irp);
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);

    //
    // The class driver is not allowed to release the device multiple
    // times.
    //
    
    ASSERT (Unit->Flags.DeviceClaimed);
    Unit->Flags.DeviceClaimed = FALSE;

    KeReleaseInStackQueuedSpinLock (&LockHandle);

    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Status = STATUS_SUCCESS;

    return RaidCompleteRequest (Irp,  Status);
}

NTSTATUS
RaUnitIoControlSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle an ioctl SRB sent to the miniport.

Arguments:

    Unit - Logical unit the ioctl SRB is for.

    Irp - IRP representing an SRB ioctl.

Return Value:

    NTSTATUS code.

--*/
{
    return RaidUnitSubmitRequest (Unit, Irp);
}



NTSTATUS
RaUnitReleaseQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PSCSI_REQUEST_BLOCK Srb;
    
    RaidThawUnitQueue (Unit);

    Srb = RaidSrbFromIrp (Irp);
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitFlushQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP FlushIrp
    )
/*++

Routine Description:

    Flush the pending queue, canceling all requests.

Arguments:

    Unit - Supplies pointer to unit to flush.

    FlushIrp - Supplies the IRP representing the flush queue request.

Return Value:

    NTSTATUS code.

Environment:

    DISPATCH_LEVEL or below.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    

    ASSERT (RaidIsUnitQueueFrozen (Unit));

    //
    // Flush all entries.
    //
    
    for (Irp = RaidRemoveIoQueue (&Unit->IoQueue);
         Irp != NULL;
         Irp = RaidRemoveIoQueue (&Unit->IoQueue)) {

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
        Irp->IoStatus.Information = 0;
        RaidCompleteRequest (Irp,  STATUS_UNSUCCESSFUL);
    }

    RaidThawUnitQueue (Unit);

    Srb = RaidSrbFromIrp (Irp);
    Srb->SrbStatus = SRB_STATUS_SUCCESS;
    FlushIrp->IoStatus.Information = 0;
    return RaidCompleteRequest (FlushIrp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitFlushSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;

    
    if (!Unit->Adapter->Miniport.PortConfiguration.CachesData) {

        //
        // If the HBA doesn't cache data, there's nothing to do.
        //

        Srb = RaidSrbFromIrp (Irp);
        Srb->SrbStatus = SRB_STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        Status = RaidCompleteRequest (Irp,  STATUS_SUCCESS);

    } else {

        //
        // Otherwise, submit this to the miniport.
        //

        Status = RaidUnitSubmitRequest (Unit, Irp);
    }

    return Status;
}

NTSTATUS
RaUnitShutdownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for SRB_FUNCTION_SHUTDOWN SRB.

Arguments:

    Unit - Supplies the logical unit that is to be shutdown.

    Irp - Supplies the IRP representing the shutdown request.

Return Value:

    NTSTATUS code.

--*/
{
    return RaidUnitSubmitRequest (Unit, Irp);
}

NTSTATUS
RaUnitWmiSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NYI();
    return RaidCompleteRequest (Irp,  STATUS_INVALID_DEVICE_REQUEST);
}

NTSTATUS
RaUnitLockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    //
    // Lock the device queue, queuing all pending IRPs for processing
    // later. This is used in Power Management.
    //

    RaidLockUnitQueue (Unit);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitUnlockQueueSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle SRB_FUNCTION_UNLOCK_QUEUE srb.

Arguments:

    Unit - Logical unit IRP is for.

    Irp - SRB_FUNCTION_UNLOCK_QUEUE Srb.

Return Value:

    NTSTATUS code.

--*/
{
    //
    // Unlock the unit device queue, allowing all queued IRPs to continue
    // processing. This is used in Power Management.
    //

    RaidUnlockUnitQueue (Unit);

    //
    // Restart the LUN queue if necessary.
    //
    
    RaidUnitRestartQueue (Unit);

    return RaidCompleteRequest (Irp,  STATUS_SUCCESS);
}

NTSTATUS
RaUnitUnknownSrb(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_REQUEST_BLOCK Srb;

    PAGED_CODE ();

    //
    // Fail requests we do not handle.
    //

    Srb = RaidSrbFromIrp (Irp);
    Srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
    Status = STATUS_NOT_SUPPORTED;
    Srb->InternalStatus = Status;

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaUnitDeviceControlIrp(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for device control (ioctl) irps.

Arguments:

    Unit - Unit to handle this irp.

    Irp - Device control irp to handle.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG Ioctl;

    PAGED_CODE ();

    Status = RaUnitAcquireRemoveLock (Unit, Irp);

    if (!NT_SUCCESS (Status)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,  Status);
    }
    
    Ioctl = RaidIoctlFromIrp (Irp);
    DebugTrace (("Unit %p, Irp %p, Ioctl = %08x\n",
                  Unit,
                  Irp,
                  Ioctl));
                 
    switch (Ioctl) {

        //
        // SCSI Ioctls
        //
        
        case IOCTL_SCSI_PASS_THROUGH:
            Status = RaUnitScsiPassThroughIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_PASS_THROUGH_DIRECT:
            Status = RaUnitScsiPassThroughIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_ADDRESS:
            Status = RaUnitScsiGetAddressIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_GET_DUMP_POINTERS:
            Status = RaUnitScsiGetDumpPointersIoctl (Unit, Irp);
            break;

        case IOCTL_SCSI_FREE_DUMP_POINTERS:
            Status = RaUnitScsiFreeDumpPointersIoctl (Unit, Irp);
            break;

        case IOCTL_STORAGE_QUERY_PROPERTY:
            Status = RaUnitStorageQueryPropertyIoctl (Unit, Irp);
            break;

        default:
            Status = RaUnitUnknownIoctl (Unit, Irp);
    }

    DebugTrace (("Unit %p, Irp %p, Ioctl = %08x, ret = %08x\n", 
                  Unit,
                  Irp,
                  Ioctl,
                  Status));

    RaUnitReleaseRemoveLock (Unit, Irp);

    return Status;
}


//
// IRP_MJ_DEVICE_CONTROL IRP handlers.
//

NTSTATUS
RaUnitScsiPassThroughIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handler routine for pass-through and pass-through direct ioctls for
    the logical unit. This routine merely adds data to some of the fields
    in the pass-through structure and passes the request down to the
    adapter.

Arguments:

    Unit - Logical unit the pass-through IRP is for.

    Irp - Irp representing a pass-through or pass-through direct IRP.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_ADAPTER_EXTENSION Adapter;

    PAGED_CODE();

    Adapter = Unit->Adapter;

    //
    // Call out to the port driver library to initialize the address.  If the
    // input buffer is not valid, an error is returned.
    //
    
    Status = PortSetPassThroughAddress (Irp,
                                        Unit->Address.PathId,
                                        Unit->Address.TargetId,
                                        Unit->Address.Lun);

    //
    // If PassThrough is NULL, fail the IRP.
    //
    
    if (!NT_SUCCESS(Status)) {
        return RaidCompleteRequest (Irp,
                                    STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // Send the IRP to the adapter. NB: This takes advantage of the
    // fact that the adapter FDO handles the request and doesn't pass
    // it onto the adapter PDO.
    //

    IoSkipCurrentIrpStackLocation (Irp);
    Status = IoCallDriver (Adapter->DeviceObject, Irp);

    return Status;
}

NTSTATUS
RaUnitScsiGetAddressIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    NTSTATUS Status;
    PSCSI_ADDRESS ScsiAddress;
    ULONG BufferLength;
    PIO_STACK_LOCATION IrpStack;
    
    PAGED_CODE ();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    ScsiAddress = Irp->AssociatedIrp.SystemBuffer;
    BufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (BufferLength < sizeof (SCSI_ADDRESS)) {
        Status = STATUS_BUFFER_TOO_SMALL;
    } else {
        ScsiAddress->Length = sizeof (SCSI_ADDRESS);
        ScsiAddress->PortNumber = (UCHAR)Unit->Adapter->PortNumber;
        ScsiAddress->PathId = Unit->Address.PathId;
        ScsiAddress->TargetId = Unit->Address.TargetId;
        ScsiAddress->Lun = Unit->Address.Lun;

        Irp->IoStatus.Information = sizeof (SCSI_ADDRESS);
        Status = STATUS_SUCCESS;
    }

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaUnitScsiGetDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Create a DUMP_POINTERS structure describing any resources necessary
    for crashdump and hiber.

Arguments:

    Unit - Unit the ioctl is for.

    Irp - Get dump pointers ioctl.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDUMP_POINTERS DumpPointers;
    PPORT_CONFIGURATION_INFORMATION Configuration;
    PIO_STACK_LOCATION IrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DMA_ADAPTER Dma;
    ULONG DumpSize;


    PAGED_CODE();

    Adapter = Unit->Adapter;
    Dma = &Adapter->Dma;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    
    //
    // Only kernel mode is allowed to get the dump pointers.
    //

    if (Irp->RequestorMode != KernelMode) {
        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
         sizeof (DUMP_POINTERS)) {
        Status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = sizeof (DUMP_POINTERS);
        goto done;
    }

    DumpPointers = (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;
    RtlZeroMemory (DumpPointers, sizeof (DUMP_POINTERS));

    //
    // Diskdump requires a complete copy of the configuration information.
    // This must be nonpaged. Also, this memory is never freed, since in
    // practice we never call FreeDumpStack.
    //
    
    Configuration = RaidAllocatePool (NonPagedPool,
                                      sizeof (PORT_CONFIGURATION_INFORMATION),
                                      CRASHDUMP_TAG,
                                      Unit->DeviceObject);

    if (Configuration == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    //
    // Initialize DMA information.
    //
    
    DumpPointers->AdapterObject = (PVOID)Dma->DmaAdapter;

    //
    // This is head of a list of MAPPED_ADDRESS structures that
    // diskdump uses to map io addresses.
    //
    
    DumpPointers->MappedRegisterBase = &Adapter->MappedAddressList;

    //
    // Copy the private port configuration.
    //

    RtlCopyMemory (Configuration,
                   &Adapter->Miniport.PortConfiguration,
                   sizeof (PORT_CONFIGURATION_INFORMATION));
    
    Configuration->SlotNumber = Adapter->SlotNumber;
    Configuration->SystemIoBusNumber = Adapter->BusNumber;
    DumpPointers->DumpData = Configuration;

    DumpPointers->UseDiskDump = TRUE;
    DumpPointers->DeviceObject = Adapter->DeviceObject;

    //
    // Set AllocateCommonBuffers to TRUE so the dump engine will
    // allocate common buffers for us.
    //
    
    DumpPointers->AllocateCommonBuffers = TRUE;

    //
    // We set the CommonBufferVa and Pa to NULL because they are never used
    // by the crashdump engine.
    //

    DumpPointers->CommonBufferVa = NULL;
    DumpPointers->CommonBufferPa.QuadPart = 0;

    //
    // Initialize the CommonBufferSize to a reasonable size for the dump
    // engine.
    //
    
    DumpSize = RaGetSrbExtensionSize (Adapter);

    if (DumpSize == 0) {
        DumpSize = 16;
    }

    //
    // Enough room for 16 SRBs.
    //
    
    DumpSize *= 16;
    DumpSize += RaidRegionGetSize (&Adapter->UncachedExtension);

    DumpPointers->CommonBufferSize = (ULONG)ROUND_TO_PAGES (DumpSize);

    Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = sizeof (DUMP_POINTERS);

done:

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaUnitScsiFreeDumpPointersIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Free any resources associated with the crashdump, hiber DUMP_POINTERS
    structure previously allocated by the get dump pointers ioctl.

Arguments:

    Unit - Unit this ioctl is for.

    Irp - Free dump pointers irp.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PDUMP_POINTERS DumpPointers;
    PIO_STACK_LOCATION IrpStack;
    PRAID_ADAPTER_EXTENSION Adapter;
    PRAID_DMA_ADAPTER Dma;

    PAGED_CODE ();

    Adapter = Unit->Adapter;
    Dma = &Adapter->Dma;
    IrpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Only kernel mode is allowed to get or free the dump pointers.
    //
    
    if (Irp->RequestorMode != KernelMode) {
        Status = STATUS_ACCESS_DENIED;
        goto done;
    }

    if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength <
         sizeof (DUMP_POINTERS)) {
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    DumpPointers= (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;

    //
    // Do some basic validation that we were actually passed in
    // a valid DUMP_POINTERS structure.
    //
    
    ASSERT (DumpPointers->AdapterObject == (PVOID)Dma->DmaAdapter);
    ASSERT (DumpPointers->MappedRegisterBase == Dma->MapRegisterBase);
    ASSERT (DumpPointers->CommonBufferSize == 0);
    ASSERT (DumpPointers->CommonBufferVa == NULL);

    RaidFreePool (DumpPointers->DumpData, CRASHDUMP_TAG);
    RtlZeroMemory (DumpPointers, sizeof (DUMP_POINTERS));
    Status = STATUS_SUCCESS;

done:

    return RaidCompleteRequest (Irp,  Status);
}



NTSTATUS
RaidUnitResetUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Reset a logical unit.

Arguments:

    Unit - Logical unit to reset.

Return Value:

    NTSTATUS code.

Environment:

     This function is in the reset path, and therefore cannot be paged.
     
--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;
    RAID_ADDRESS Address;
    PRAID_ADAPTER_EXTENSION Adapter;

    //
    // Initialization to NULL
    //

    Irp = NULL;
    Srb = NULL;

    //
    // Validate that we're not doing this for an invalid address.
    //
    
    Address = RaidUnitGetAddress (Unit);
    ASSERT (StorCompareScsiAddress (Address, RaidNullAddress) != 0);

    //
    // Build a SRB for this request.
    //

    Srb = RaidAllocateSrb (Unit->DeviceObject);

    if (Srb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    //
    // Build the SRB.
    //

    Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_RESET_LOGICAL_UNIT;
    Srb->PathId = Unit->Address.PathId;
    Srb->TargetId = Unit->Address.TargetId;
    Srb->Lun = Unit->Address.Lun;
    Srb->SrbFlags = SRB_FLAGS_NO_QUEUE_FREEZE
                  | SRB_FLAGS_BYPASS_FROZEN_QUEUE
                  | SRB_FLAGS_BYPASS_LOCKED_QUEUE;
 
    Srb->QueueTag = -1;
    Srb->DataBuffer = NULL;
    Srb->DataTransferLength = 0;
    Srb->OriginalRequest = Irp;
    Srb->TimeOutValue = max (MINIMUM_RESET_TIMEOUT, Unit->DefaultTimeout);

    //
    // Initialize the event we will wait on.
    //
    
    KeInitializeEvent (&Event,
                       NotificationEvent,
                       FALSE);
    //
    // Allocate and initialize the IRP for this request.
    //
    
    Irp = StorBuildSynchronousScsiRequest (Unit->DeviceObject,
                                           Srb,
                                           &Event,
                                           &IoStatus);

    
    if (Irp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    //
    // Submit the to the logical unit. This request IS submitted through
    // the logical unit queuing logic.
    //

    Status = IoCallDriver (Unit->DeviceObject, Irp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject (&Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        Status = IoStatus.Status;
    }

    //
    // NB: If successful, we should pause for RESET_HOLD_TIME
    // here.
    //

cleanup:

    if (Srb != NULL) {
        RaidFreeSrb (Srb);
        Srb = NULL;
    }

    return Status;
}



NTSTATUS
RaidUnitResetTarget(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Reset a target.

Arguments:

    Unit - Unit that the target is a part if.

Return Value:

    NTSTATUS code.

Environment:

    This function is in the reset path, and therefore cannot be paged.

--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;
    RAID_ADDRESS Address;

    //
    // Initialization to NULL
    //

    Irp = NULL;
    Srb = NULL;

    Address = RaidUnitGetAddress (Unit);
    ASSERT (StorCompareScsiAddress (Address, RaidNullAddress) != 0);
    
    //
    // Build a SRB for this request.
    //

    Srb = RaidAllocateSrb (Unit->DeviceObject);

    if (Srb == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }

    //
    // Build the SRB.
    //

    Srb->Length = sizeof (SCSI_REQUEST_BLOCK);
    Srb->Function = SRB_FUNCTION_RESET_DEVICE;
    Srb->PathId = Unit->Address.PathId;
    Srb->TargetId = Unit->Address.TargetId;
    Srb->Lun = 0;
    Srb->SrbFlags = SRB_FLAGS_NO_QUEUE_FREEZE |
                    SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                    SRB_FLAGS_BYPASS_LOCKED_QUEUE;
    Srb->QueueTag = -1;
    Srb->DataBuffer = NULL;
    Srb->DataTransferLength = 0;
    Srb->OriginalRequest = Irp;
    Srb->TimeOutValue = max (MINIMUM_RESET_TIMEOUT, Unit->DefaultTimeout);

    //
    // Initialize the event we will wait on.
    //
    
    KeInitializeEvent (&Event,
                       NotificationEvent,
                       FALSE);
    //
    // Allocate and initialize the IRP for this request.
    //
    
    Irp = StorBuildSynchronousScsiRequest (Unit->DeviceObject,
                                           Srb,
                                           &Event,
                                           &IoStatus);

    
    if (Irp == NULL) {
        Status = STATUS_NO_MEMORY;
        goto cleanup;
    }


    //
    // Submit the to the logical unit. This request IS submitted through
    // the logical unit queuing logic.
    //

    Status = IoCallDriver (Unit->DeviceObject, Irp);

    if (Status == STATUS_PENDING) {
        KeWaitForSingleObject (&Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        Status = IoStatus.Status;
    }

    //
    // NB: If successful, we should pause for RESET_HOLD_TIME
    // here.
    //

cleanup:

    if (Srb != NULL) {
        RaidFreeSrb (Srb);
        Srb = NULL;
    }

    return Status;
}


NTSTATUS
RaUnitStorageQueryDevicePropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IOCTL_STORAGE_QUERY_PROPERTY with PropertyId of
    StorageDeviceProperty sent to the LUN.

Arguments:

    Unit - Supplies the unit/pdo the ioctl is for.

    Irp - Supplies the IRP representing the IOCTL.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;
    PVOID Buffer;
    ULONG BufferSize;

    PAGED_CODE();

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;
    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    ASSERT (BufferSize >= FIELD_OFFSET (STORAGE_PROPERTY_QUERY, AdditionalParameters));

    switch (Query->QueryType) {

        case PropertyExistsQuery:
            Status = STATUS_SUCCESS;
            break;

        case PropertyStandardQuery:
            Status = RaGetUnitStorageDeviceProperty (Unit,
                                                     Buffer,
                                                     &BufferSize);
            if (NT_SUCCESS (Status)) {
                Irp->IoStatus.Information = BufferSize;
            } else {
                Irp->IoStatus.Information = 0;
            }
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
    }

    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitStorageQueryDeviceIdPropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IOCTL_STORAGE_QUERY_PROPERTY with PropertyId of
    StorageDeviceIdProperty sent to the LUN.

Arguments:

    Unit - Supplies the unit/pdo the ioctl is for.

    Irp - Supplies the IRP representing the IOCTL.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;
    PVOID Buffer;
    ULONG BufferSize;

    PAGED_CODE();
    
    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;
    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

    ASSERT (BufferSize >= FIELD_OFFSET (STORAGE_PROPERTY_QUERY, AdditionalParameters));
    
    //
    // Determine whether the Page 0x83 data is available for this unit.
    //

    if (Unit->Identity.DeviceId == NULL) {
        return RaidCompleteRequest (Irp,
                                    
                                    STATUS_NOT_SUPPORTED);
    }

    switch (Query->QueryType) {

        case PropertyExistsQuery:
            Status = STATUS_SUCCESS;
            break;

        case PropertyStandardQuery:
            Status = RaGetUnitStorageDeviceIdProperty (Unit,
                                                       Buffer, 
                                                       &BufferSize);
            if (NT_SUCCESS(Status)) {
                Irp->IoStatus.Information = BufferSize;
            }
            break;

        default:
            Status = STATUS_NOT_SUPPORTED;
    }

    return RaidCompleteRequest (Irp,  Status);
}


NTSTATUS
RaUnitStorageQueryPropertyIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IOCTL_STORAGE_QUERY_PROPERTY sent to the lun.

Arguments:

    Unit - Logical unit to handle the ioctl.

    Irp - Query property IRP.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    ULONG BufferSize;
    PIO_STACK_LOCATION IrpStack;
    PSTORAGE_PROPERTY_QUERY Query;


    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    IrpStack = IoGetCurrentIrpStackLocation (Irp);
    Query = Irp->AssociatedIrp.SystemBuffer;    
    BufferSize = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;


    if (BufferSize < FIELD_OFFSET (STORAGE_PROPERTY_QUERY, AdditionalParameters)) {
        Irp->IoStatus.Information = 0;
        return RaidCompleteRequest (Irp,
                                    STATUS_INVALID_PARAMETER_1);
    }

    switch (Query->PropertyId) {

        case StorageDeviceProperty:
            Status = RaUnitStorageQueryDevicePropertyIoctl (Unit, Irp);
            break;

        case StorageDeviceIdProperty:
            Status = RaUnitStorageQueryDeviceIdPropertyIoctl (Unit, Irp);
            break;

        default:

            //
            // Send unknown property request down the stack.
            //
            
            IoSkipCurrentIrpStackLocation (Irp);
            Status = IoCallDriver (Unit->Adapter->DeviceObject, Irp);
    }

    return Status;
}

NTSTATUS
RaUnitUnknownIoctl(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
{
    PAGED_CODE ();

    return RaidCompleteRequest (Irp,
                                STATUS_INVALID_DEVICE_REQUEST);
}


NTSTATUS
RaidUnitGetDeviceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* DeviceIdBuffer
    )
{
    NTSTATUS Status;
    PWCHAR DeviceId;
    PCSCSI_DEVICE_TYPE DeviceType;
    CHAR VendorId [SCSI_VENDOR_ID_LENGTH + 1];
    CHAR ProductId [SCSI_PRODUCT_ID_LENGTH + 1];
    CHAR Revision [SCSI_REVISION_ID_LENGTH + 1];
    ULONG i;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    DeviceId = RaidAllocatePool (PagedPool,
                                 DEVICE_ID_LENGTH * sizeof (WCHAR),
                                 ID_TAG,
                                 Unit->DeviceObject);

    if (DeviceId != NULL) {

        DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

        StorGetIdentityVendorId (&Unit->Identity,
                                 VendorId,
                                 sizeof (VendorId),
                                 TRUE);

        StorGetIdentityProductId (&Unit->Identity,
                                  ProductId,
                                  sizeof (ProductId),
                                  TRUE);

        StorGetIdentityRevision (&Unit->Identity,
                                 Revision,
                                 sizeof (Revision),
                                 TRUE);

        swprintf (DeviceId,
             L"SCSI\\%hs&Ven_%hs&Prod_%hs&Rev_%hs",
             DeviceType->Name,
             VendorId,
             ProductId,
             Revision);

        RaFixupIds (DeviceId, FALSE);

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_NO_MEMORY;
    }

    *DeviceIdBuffer = DeviceId;

    return Status;
}


NTSTATUS
RaidUnitGetInstanceId(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* InstanceIdBuffer
    )
{
    NTSTATUS Status;
    PWCHAR InstanceId;
    ULONG Count;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    InstanceId = RaidAllocatePool (PagedPool,
                                   INSTANCE_ID_LENGTH * sizeof (WCHAR),
                                   ID_TAG,
                                   Unit->DeviceObject);

    if (InstanceId != NULL) {

        Count = swprintf (InstanceId,
                          L"%x%x%x",
                          Unit->Address.PathId,
                          Unit->Address.TargetId,
                          Unit->Address.Lun
                          );

        //
        // Sanity check that we didn't overflow our buffer.
        //
        
        ASSERT ((Count + 1) < INSTANCE_ID_LENGTH);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_NO_MEMORY;
    }

    *InstanceIdBuffer = InstanceId;

    return Status;
}


BOOLEAN
RaidUnitIsMultiPathSupported(
    IN PDRIVER_OBJECT DriverObject,        
    IN PINQUIRYDATA InquiryData
    )
/*++

Routine Description:

    This routine is used to determine whether the device represented by InquiryData is
    being supported by MPIO. 

Arguments:

    DriverObject - This driver's DrvObj. Contains the DriveObjectExtension.
    InquiryData - Scsi inquiry data.

Return Value:

    TRUE - If MPIO is installed for the device.

--*/
{
    PRAID_DRIVER_EXTENSION driverExt;
    UCHAR vendorId[9];
    UCHAR productId[17];
    BOOLEAN supported = FALSE;

    //
    // Check whether the device is even supported (disk).
    //

    if (InquiryData->DeviceType == DIRECT_ACCESS_DEVICE) {

        //
        // Get the driver object ext., which contains the supported list.
        //

        driverExt = IoGetDriverObjectExtension(DriverObject,
                                               DriverEntry);
        if (driverExt) {

            //
            // Get local null-terminated copies of the inquiry data.
            //
            
            RtlZeroMemory(&vendorId, 9);
            RtlZeroMemory(&productId, 17);
            
            RtlCopyMemory(vendorId, InquiryData->VendorId, 8);
            RtlCopyMemory(productId, InquiryData->ProductId, 16);

            //
            // Check to see whether this device is in the list.
            //

            supported = PortIsDeviceMPIOSupported(&driverExt->MPIOSupportedDeviceList,
                                                  vendorId,
                                                  productId);
        }    
    }
    
    return supported;
}

NTSTATUS
RaidUnitGetHardwareIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* HardwareIdsBuffer
    )
{
    NTSTATUS Status;
    PWCHAR HardwareIds;
    ULONG Count;
    PWCHAR Buffer;
    PCSCSI_DEVICE_TYPE DeviceType;
    PINQUIRYDATA InquiryData;

    PAGED_CODE ();
    ASSERT_UNIT (Unit);

    HardwareIds = RaidAllocatePool (PagedPool,
                                    HARDWARE_ID_LENGTH * sizeof (WCHAR),
                                    ID_TAG,
                                    Unit->DeviceObject);
                                         

    if (HardwareIds != NULL) {

        Buffer = HardwareIds;
        InquiryData = StorGetIdentityInquiryData (&Unit->Identity);
        DeviceType = PortGetDeviceType (InquiryData->DeviceType);

        //
        // bus + device + vendor + product + revision
        //
        // For example: "SCSI\DiskSEAGATE_ST318451FC______0001"
        //
        //
        
        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs%16.16hs%4.4hs",
                          DeviceType->Name,
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel);

        Buffer += (Count + 1);

        //
        // bus + device + vendor + product
        //
        // For example: "SCSI\DiskSEAGATE_ST318451FC______"
        //

        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs%16.16hs",
                          DeviceType->Name,
                          InquiryData->VendorId,
                          InquiryData->ProductId);

        Buffer += (Count + 1);

        //
        // bus + device + vendor
        //
        // For example: "SCSI\DiskSEAGATE_"
        //

        Count = swprintf (Buffer,
                          L"SCSI\\%hs%8.8hs",
                          DeviceType->Name,
                          InquiryData->VendorId);

        Buffer += (Count + 1);

        //
        // bus + vendor + product + revision[0]
        //
        // For example: "SCSI\SEAGATE_ST318451FC______0"

        Count = swprintf (Buffer,
                          L"SCSI\\%8.8hs%16.16hs%hc",
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel[0]);

        Buffer += (Count + 1);

        //
        // vendor + product + revision[0]
        //
        // For example: "SEAGATE_ST318451FC______0___"
        //

        Count = swprintf (Buffer,
                          L"%8.8hs%16.16hs%hc",
                          InquiryData->VendorId,
                          InquiryData->ProductId,
                          InquiryData->ProductRevisionLevel[0]);
                          
        Buffer += (Count + 1);
        
        //
        // generic device
        //
        // For example: "GenDisk" or "MPIODisk" if mpio is supporting the device.
        // 
        // Determine whether this is a GenDisk or not.
        //
        if (RaidUnitIsMultiPathSupported(Unit->Adapter->DeviceObject->DriverObject,
                                         InquiryData)) {

            //
            // This is on the mpio support list. Build the MPIODisk Generic ID against
            // which mpdev.sys loads.
            //
            
            Count = swprintf (Buffer,
                              L"%hs",
                              "MPIODisk");
        } else {    

            //
            // Not mpio supported. Build the regular name (ie GenDisk).
            //

            Count = swprintf (Buffer,
                              L"%hs",
                              DeviceType->GenericName);
        }            

        Buffer += (Count + 1);

        *Buffer++ = UNICODE_NULL;
        RaFixupIds (HardwareIds, TRUE);
        Status = STATUS_SUCCESS;

        ASSERT ((LONG)(Buffer - HardwareIds) < HARDWARE_ID_LENGTH);

    } else {

        Status = STATUS_NO_MEMORY;
    }

    *HardwareIdsBuffer = HardwareIds;

    return Status;
}


NTSTATUS
RaidUnitGetCompatibleIds(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PWSTR* CompatibleIdsBuffer
    )
{
    NTSTATUS Status;
    PWCHAR CompatibleIds;
    PWCHAR Buffer;
    ULONG Count;
    PCSCSI_DEVICE_TYPE DeviceType;

    PAGED_CODE ();

    CompatibleIds = RaidAllocatePool (PagedPool,
                                      COMPATIBLE_ID_LENGTH * sizeof (WCHAR),
                                      ID_TAG,
                                      Unit->DeviceObject);

    if (CompatibleIds != NULL) {

        Buffer = CompatibleIds;
        DeviceType = StorGetIdentityDeviceType (&Unit->Identity);

        //
        // First is, SCSI\<DEVICE>
        //
        
        Count = swprintf (Buffer, L"SCSI\\%hs", DeviceType->Name);
        Buffer += (Count + 1);

        //
        // Second is SCSI\RAW
        //
        
        Count = swprintf (Buffer, L"SCSI\\RAW");
        Buffer += (Count + 1);

        //
        // Append the final UNICODE_NULL because this is a multi-sz string.
        //
        
        *Buffer++ = UNICODE_NULL;

        //
        // Remove invalid characters.
        //
        
        RaFixupIds (CompatibleIds, TRUE);

        //
        // Sanity check that we didn't overflow our allocated buffer.
        //
        
        ASSERT ((ULONG)(Buffer - CompatibleIds) < COMPATIBLE_ID_LENGTH);

        Status = STATUS_SUCCESS;

    } else {
        Status = STATUS_NO_MEMORY;
    }

    *CompatibleIdsBuffer = CompatibleIds;

    return Status;
}


NTSTATUS
RaGetUnitStorageDeviceProperty(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PSTORAGE_DEVICE_DESCRIPTOR DescriptorBuffer,
    IN OUT PULONG BufferLength
    )
/*++

Routine Description:

    Create a device descriptor based on the information in the device
    extension. Copy as much data as possible into the Decescriptor and
    update the DescriptorLength to indicate the number of bytes copied

Arguments:

    Unit - Supplies Unit we are querying property for.

    DescriptorBuffer - Pointer to a buffer where the data for this
            property will be copied. The buffer size is determined by the
            input value of the BufferLength parameter.

    BufferLength - On input, supplies the length of the buffer, on output
            return the number of bytes copied.

Return Value:

    NTSTATUS code.

--*/
{
    PRAID_DRIVER_EXTENSION Driver;
    PINQUIRYDATA InquiryData;
    PSTOR_SCSI_IDENTITY Identity;
    RAID_DEVICE_DESCRIPTOR Descriptor;
    ULONG Length;


    PAGED_CODE();
    ASSERT_UNIT (Unit);
    ASSERT (DescriptorBuffer != NULL);


    InquiryData = StorGetIdentityInquiryData (&Unit->Identity);

    Identity = &Unit->Identity;

    //
    // Zero the temporary descriptor buffer out. Note that since
    // we don't explicitly zero out or NULL-terminated strings
    // below, the zeroing is necessary.
    //

    RtlZeroMemory (&Descriptor, sizeof (Descriptor));

    //
    // Length is the number of bytes we will copy into the descriptor
    // buffer. The Size field in the storage descriptor is the size
    // of the descriptor we want to copy -- not the number of bytes
    // copied. This is important.
    //
    
    Length = min (((ULONG)sizeof (Descriptor)), *BufferLength);

    Descriptor.Storage.Version = sizeof (STORAGE_DEVICE_DESCRIPTOR);
    Descriptor.Storage.Size = sizeof (Descriptor);
    Descriptor.Storage.DeviceType = InquiryData->DeviceType;
    Descriptor.Storage.DeviceTypeModifier = InquiryData->DeviceTypeModifier;
    Descriptor.Storage.RemovableMedia = InquiryData->RemovableMedia;
    Descriptor.Storage.CommandQueueing = InquiryData->CommandQueue; 
    Descriptor.Storage.BusType = Unit->Adapter->Parameters.BusType;

    //
    // Copy the VendorId and initialize it's field offset.
    //
    
    RtlCopyMemory (Descriptor.VendorId,
                   InquiryData->VendorId,
                   sizeof (Descriptor.VendorId) - 1);

    Descriptor.Storage.VendorIdOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, VendorId);

    //
    // Copy the ProductId and initialize it's field offset.
    //
    
    RtlCopyMemory (Descriptor.ProductId,
                   InquiryData->ProductId,
                   sizeof (Descriptor.ProductId) - 1);

    Descriptor.Storage.ProductIdOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, ProductId);

    //
    // Copy the RevisionLevel and initialize it's offset.
    //

    RtlCopyMemory (Descriptor.ProductRevision,
                   InquiryData->ProductRevisionLevel,
                   sizeof (Descriptor.ProductRevision) - 1);

    Descriptor.Storage.ProductRevisionOffset =
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, ProductRevision);


    //
    // Copy the serial number.
    //
    
    if (Identity->SerialNumber.MaximumLength) {

        ASSERT(Identity->SerialNumber.Buffer);

        Descriptor.Storage.SerialNumberOffset = 
            FIELD_OFFSET (RAID_DEVICE_DESCRIPTOR, SerialNumber);

        RtlZeroMemory(Descriptor.SerialNumber, 
                      sizeof(Descriptor.SerialNumber));

        RtlCopyMemory(Descriptor.SerialNumber,
                      Identity->SerialNumber.Buffer,
                      sizeof (Identity->SerialNumber));
    } else {
        Descriptor.Storage.SerialNumberOffset = 0;
    }


    //
    // Copy the temporary descriptor back to the buffer, and update the
    // length parameter.
    //
    
    RtlCopyMemory (DescriptorBuffer, &Descriptor, Length);
    *BufferLength = Length;

    return STATUS_SUCCESS;
}

NTSTATUS
RaGetUnitStorageDeviceIdProperty (
    IN PRAID_UNIT_EXTENSION Unit,
    IN PSTORAGE_DEVICE_ID_DESCRIPTOR DescriptorBuffer,
    IN OUT PULONG BufferLength
    )
/*++

Routine Description:

    This routine builds the DEVICE_ID_DESCRIPTOR based on the raw 0x83 data for Unit,
    if the data is available.
   
    NOTE: This is pretty much ripped off from scsiport.

Arguments:

    Unit - The Logical Unit for which the descriptor is needed.
    DescriptorBuffer - storage for the return data.
    BufferLength - Available buffer size, updated to actual data size.

Return Value:

    INVALID_PARAMETER if BufferLength is too small.
    SUCCESS 

--*/
{
    PVPD_IDENTIFICATION_PAGE idPage = Unit->Identity.DeviceId;
    ULONG idOffset;

    ULONG maxLength = *BufferLength;
    PUCHAR destOffset;

    LONG identifierLength;
    ULONG identifierCount = 0;

    PAGED_CODE();

    ASSERT(DescriptorBuffer != NULL);
    ASSERT(Unit->Identity.DeviceId != NULL);

    if(maxLength < sizeof(STORAGE_DESCRIPTOR_HEADER)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Initialize the header of the descriptor.
    //

    RtlZeroMemory(DescriptorBuffer, maxLength);
    DescriptorBuffer->Version = sizeof(STORAGE_DEVICE_ID_DESCRIPTOR);
    DescriptorBuffer->Size = FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR, Identifiers);

    //
    // Prepare to copy the identifiers directly into the buffer.
    //

    destOffset = DescriptorBuffer->Identifiers;

    //
    // Walk through the id page.  Count the number of descriptors and
    // calculate the size of the descriptor page.
    //

    for (idOffset = 0; idOffset < idPage->PageLength;) {
        PVPD_IDENTIFICATION_DESCRIPTOR src;
        USHORT identifierSize;

        //
        // Get the next page 0x83 descriptor.
        // 
        src = (PVPD_IDENTIFICATION_DESCRIPTOR) &(idPage->Descriptors[idOffset]);

        //
        // Set the size - size of the 'header', plus the actual identifier.
        // 
        identifierSize = FIELD_OFFSET(STORAGE_IDENTIFIER, Identifier);
        identifierSize += src->IdentifierLength;

        //
        // Align the identifier size to 32-bits.
        //

        identifierSize += sizeof(ULONG);
        identifierSize &= ~(sizeof(ULONG) - 1);

        identifierCount += 1;

        DescriptorBuffer->Size += identifierSize;

        if (DescriptorBuffer->Size <= maxLength) {
            PSTORAGE_IDENTIFIER dest;

            //
            // There is remaining length in the buffer, so build the descriptor.
            // 
            dest = (PSTORAGE_IDENTIFIER) destOffset;

            dest->CodeSet = src->CodeSet;
            dest->Type = src->IdentifierType;
            dest->Association = src->Association;

            dest->IdentifierSize = src->IdentifierLength;
            dest->NextOffset = identifierSize;

            RtlCopyMemory(dest->Identifier,
                          src->Identifier,
                          src->IdentifierLength);

            destOffset += dest->NextOffset;
        }

        idOffset += sizeof(PVPD_IDENTIFICATION_DESCRIPTOR);
        idOffset += src->IdentifierLength;
    }

    if (*BufferLength >= FIELD_OFFSET(STORAGE_DEVICE_ID_DESCRIPTOR,
                                        Identifiers)) {

        DescriptorBuffer->NumberOfIdentifiers = identifierCount;
    }

    *BufferLength = min(DescriptorBuffer->Size, *BufferLength);

    return STATUS_SUCCESS;

}


VOID
RaidSetUnitPauseTimer(
    IN PRAID_UNIT_EXTENSION Unit,
    IN ULONG TimeoutInSeconds
    )
/*++

Routine Description:

    Pause the logical unit queue with a timeout.

Arguments:

    Unit - Logical unit to pause.

    Timeout - Timeout for the pause.

Return Value:

    None.

--*/
{
    BOOLEAN Reset;
    LOGICAL Resumed;
    LARGE_INTEGER LargeTimeout;

    LargeTimeout.QuadPart = TimeoutInSeconds;
    LargeTimeout.QuadPart *= RELATIVE_TIMEOUT;
    LargeTimeout.QuadPart *= SECONDS;

    Reset = KeSetTimer (&Unit->PauseTimer,
                        LargeTimeout,
                        &Unit->PauseTimerDpc);

    if (Reset) {

        //
        // The timer was already in use, which means we successfully
        // cancelled it. By cancelling it, we loose the dereference owned
        // by the timer routine. Perform that deref here.
        //

        Resumed = RaidResumeUnitQueue (Unit);

        //
        // It is theoritically possible that by the time we resumed the
        // LUN queue our timeout has already fired. (Short timeout period
        // coupled with long interrupt in between, maybe?) If this happens
        // we will resume the unit queue, so we have to restart it. I've
        // put a review here because I'd like to take a look at this case;
        // it would be very unusual indeed.
        
        if (Resumed) {
            REVIEW();
            RaidUnitRestartQueue (Unit);
        }
    }
}

                        
VOID
RaidCancelTimerResumeUnit(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Cancel the outstanding pause timer and resume the logical unit queue if
    necessary.

    This function will work correctly even if an already canceled timer is
    canceled.
    
Arguments:

    Unit - Unit to cancel the pause timer on.

Return Value:

    None.

--*/
{
    LOGICAL Resumed;
    BOOLEAN Canceled;
    
    //
    // Cancel the timeout counter.
    //
    
    Canceled = KeCancelTimer (&Unit->PauseTimer);

    //
    // If we were successful, resume the logical unit queues.
    //

    if (Canceled) {

        //
        // If the pause count hit zero, restart the LUN queue.
        //

        Resumed = RaidResumeUnitQueue (Unit);

        if (Resumed) {
            RaidUnitRestartQueue (Unit);
        }
    }
}


VOID
RaidUnitProcessBusyRequest(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    Process a request that has come to us as busy.

Arguments:

    Unit - Supplies the logical unit that this request was submitted to.

    Xrb - Supplies the request.

Return Value:

    None.

--*/
{
    PSCSI_REQUEST_BLOCK Srb;
    PIRP Irp;
    PEXTENDED_DEVICE_QUEUE ExQueue;
    PSTOR_IO_GATEWAY Gateway;
    RAID_IO_RESOURCES IoResources;
    LOGICAL Started;
    ULONG Flags;
    
    Srb = Xrb->Srb;
    Irp = Xrb->Irp;

    //
    // SRB_STATUS_BUSY signals an adapter is busy.
    //

    ASSERT (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_BUSY ||
            SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_LINK_DOWN ||
            Srb->ScsiStatus == SCSISTAT_BUSY ||
            Srb->ScsiStatus == SCSISTAT_QUEUE_FULL);

    RaidUnitReleaseIrp (Irp, &IoResources);

    //
    // After releasing the Irp, we no longer have a Xrb to play with.
    //
    
    Xrb = NULL;

    //
    // Remove the IRP from the list of outstanding IRPs
    //
    
    RaidDeleteExDeviceQueueEntry (&Unit->IoQueue.DeviceQueue);

    //
    // Then resubmit it.
    //

    Flags = 0;
    
    //
    // Mark this as a bypass request if appropiate.
    //

    if (TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_FROZEN_QUEUE) ||
        TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_BYPASS_LOCKED_QUEUE)) {
        Flags |= EXQ_BYPASS_REQUEST;
    }

    //
    // If this is a solitary request, set the solitary request flag.
    //
    
    if (IsSolitaryRequest (Srb)) {
        Flags |= EXQ_SOLITARY_REQUEST;
    }

    Started = RaidStartIoPacket (&Unit->IoQueue,
                                 Irp,
                                 Flags,
                                 NULL,
                                 &IoResources);
                       

    if (!Started) {
        RaidUnitFreeIoResources (Unit, &IoResources);

        //
        // The queues need to be restarted in the case that
        //   (a) we were performing a solitary request and
        //   (b) there is a solitary pending
        //
        //    We may be able to do this differently, more elegantly.
        //

        RaidUnitRestartQueue (Unit);
    }
}


LOGICAL
INLINE
IsBusy(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_BUSY ||
            Srb->ScsiStatus == SCSISTAT_BUSY ||
            Srb->ScsiStatus == SCSISTAT_QUEUE_FULL);
}

LOGICAL
INLINE
IsLinkDown(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_LINK_DOWN);
}

VOID
RaUnitAsyncError(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PEXTENDED_REQUEST_BLOCK Xrb
    )
/*++

Routine Description:

    This routine handles errors asynchronous errors.

Arguments:

    Unit - Supplies Logical Unit that Xrb is for.

    Xrb - Supplies Xrb that caused an error.

Return Value:

    None.

--*/
{

    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    BOOLEAN RestartQueues;

    ASSERT_XRB (Xrb);

    Irp = Xrb->Irp;
    Srb = Xrb->Srb;
    RestartQueues = FALSE;

    DebugScsi (("Unit %p Srb %p, generated err = %08x\n",
                  Unit,
                  Srb,
                  SRB_STATUS (Srb->SrbStatus)));

    //
    // If the request asked us to freeze the logical unit's queue and
    // the queue is not already frozen, freeze it.
    //
    // It is necessary to check if it's already frozen because some
    // requests can bypass the queue. Double freezing or locking of
    // the queue is not supported.
    //
    
    if (!TEST_FLAG (Srb->SrbFlags, SRB_FLAGS_NO_QUEUE_FREEZE) &&
        !RaidIsUnitQueueFrozen (Unit)) {

        //
        // Freeze the queue so the class driver has a chance to process
        // the error.
        //

        RaidFreezeUnitQueue (Unit);
        SET_FLAG (Srb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
    }

    //
    // Check for busy or link down.  In either case, we resubmit the request.
    // The request will be requeued and restarted later.
    //

    if (IsBusy (Srb) || IsLinkDown (Srb)) {
        RaidUnitProcessBusyRequest (Unit, Xrb);
        return;
    }

    //
    // Propagate the translated error condition in the IRP.
    //
    
    Irp->IoStatus.Status = RaidSrbStatusToNtStatus (Srb->SrbStatus);

    if (SRB_STATUS (Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {
        Irp->IoStatus.Information = Srb->DataTransferLength;
    } else {
        Irp->IoStatus.Information = 0;
    }

    //
    // Release any resources associated with the IRP.
    //

    RaidUnitReleaseIrp (Irp, NULL);

    //
    // Finally, complete the request.
    //
    
    DebugScsi (("Unit %p, Irp %p, completing = %08x\n",
                 Unit,
                 Irp,
                 Irp->IoStatus.Status));

    DbgLogRequest (LogRequestComplete,
                   Irp,
                   (PVOID)(ULONG_PTR)(Irp->IoStatus.Status),
                   (PVOID)(ULONG_PTR)(Srb->SrbStatus),
                   NULL);
                    
    RaidCompleteRequest (Irp, Irp->IoStatus.Status);

    RaidStartNextIoPacket (&Unit->IoQueue,
                           FALSE,
                           NULL,
                           &RestartQueues);

    if (RestartQueues) {
        RaidAdapterRestartQueues (Unit->Adapter);
    }
}


VOID
RaidUnitRestartQueue(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    RaidRestartIoQueue(&Unit->IoQueue); 
}


VOID
RaUnitAddToPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Add the specified IO request to the pending list.

Arguments:

    Unit - Logical unit whose event queue the IRP should be added to.

    Irp - Irp that should be added.

Return Value:

    None.

--*/
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    Xrb = RaidXrbFromIrp (Irp);
    ASSERT (Xrb != NULL);
    ASSERT (Xrb->Srb != NULL);

    //
    // Signal that this XRB must be removed from the event queue.
    //
    
    Xrb->RemoveFromEventQueue = TRUE;
    StorInsertEventQueue (&Unit->PendingQueue,
                          &Xrb->PendingLink,
                          Xrb->Srb->TimeOutValue);
    
}


VOID
RaUnitRemoveFromPendingList(
    IN PRAID_UNIT_EXTENSION Unit,
    IN PIRP Irp
    )
/*++

Routine Description:

    Remove the specified element from the pending list.

Arguments:

    Unit - Logical unit whose pending list the IRP is on.

    Irp - Irp that should be removed.

Return Value:

    None.

--*/
{
    PEXTENDED_REQUEST_BLOCK Xrb;

    Xrb = RaidXrbFromIrp (Irp);
    ASSERT (Xrb != NULL);

    //
    // Only remove the IRP if the RemoveFromPendingQueue flag is still
    // set. Otherwise, somebody (purge routine) is likely holding the
    // event queue spinlock and we will hang. The element will be
    // automatically removed from the event queue as a part of the
    // purge routine.
    //
    
    if (Xrb->RemoveFromEventQueue) {
        StorRemoveEventQueue (&Unit->PendingQueue, &Xrb->PendingLink);
    }
}


BOOLEAN
RaidUnitIsEnumerated(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    //
    // This should be an atomic operation, so there is no need to
    // acquire the SlowLock.
    //
    
    return Unit->Flags.Enumerated;
}


BOOLEAN
RaidUnitSetEnumerated(
    IN PRAID_UNIT_EXTENSION Unit,
    IN BOOLEAN Enumerated
    )
{
    BOOLEAN PreviouslyEnumerated;
    KLOCK_QUEUE_HANDLE LockHandle;
    
    KeAcquireInStackQueuedSpinLock (&Unit->SlowLock, &LockHandle);
    PreviouslyEnumerated = Unit->Flags.Enumerated;
    Unit->Flags.Enumerated = Enumerated;
    KeReleaseInStackQueuedSpinLock (&LockHandle);

    return PreviouslyEnumerated;
}


PVOID
RaidGetKeyFromUnit(
    IN PSTOR_DICTIONARY_ENTRY Entry
    )
{
    PVOID Key;
    PRAID_UNIT_EXTENSION Unit;
    
    Unit = CONTAINING_RECORD (Entry,
                              RAID_UNIT_EXTENSION,
                              UnitTableLink);

    ASSERT_UNIT (Unit);

    Key = RaidAddressToKey (Unit->Address);

    return (PVOID) Key;
}


VOID
RaidHierarchicalResetWorkRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

    This function is called from a work-queue item, to perform a hierarchical
    bus reset.

Arguments:

    DeviceObject - Device object representing a logical unit.

    Context - The work-item to free when we've completed.

Return Value:

    None.

Environment:

    This function is in the reset path, therefore cannot be paged.

--*/

{
    PRAID_UNIT_EXTENSION Unit;
    PIO_WORKITEM WorkItem;
    
    Unit = DeviceObject->DeviceExtension;
    WorkItem = (PIO_WORKITEM)Context;
    ASSERT_UNIT (Unit);
    ASSERT (WorkItem != NULL);

    RaidUnitHierarchicalReset (Unit);
    IoFreeWorkItem (WorkItem);
}



VOID
RaidUnitPendingDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is invoked every second to check if we have timed out
    

Arguments:

    Dpc - Dpc object.

    DeviceObject - Device object for the logical unit.

    SystemArgument1 - Not used.

    SystemArgument2 - Not used.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    
    VERIFY_DISPATCH_LEVEL();

    Unit = (PRAID_UNIT_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);


    //
    // Tick the outstanding timer. If an IO has timed out, we will
    // get back STATUS_IO_TIMEOUT, otherwise STATUS_SUCCESS.
    //
    
    Status = StorTickEventQueue (&Unit->PendingQueue);

    //
    // If we were successful, leave.
    //
    
    if (NT_SUCCESS (Status)) {
        return;
    }

    //
    // Otherwise, a request has timed out.
    //
    
    RaidUnitRequestTimeout (Unit);
}


VOID
RaidUnitRequestTimeout(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine is called when we detect a request has timed out. We need
    to perform either a hierarchical reset or a bus reset.

Arguments:

    Unit - Logical unit that a request has timeout out on.

Return Value:

    None.

--*/
{
    RAID_ADDRESS Address;
    PIO_WORKITEM WorkItem;

    Address = RaidUnitGetAddress (Unit);
    
    DebugWarn (("WARNING: One or more I/Os timed out. Attempting to recover\n"));
    DebugWarn (("WARNING: by resetting %d %d %d\n",
                 (ULONG)Address.PathId,
                 (ULONG)Address.TargetId,
                 (ULONG)Address.Lun));

    //
    // NB: Is it necessary to log an event here?
    //
    
    //
    // We have an outstanding reset command which failed to complete
    // in the required time period. At this point, use the hammer
    // (synchronous bus reset) reset it.
    //
    
    if (Unit->ResetCount != 0) {
        DebugPrint (("ERROR: An outstanding reset command is queued to %d, %d, %d\n",
                      Address.PathId,
                      Address.TargetId,
                      Address.Lun));
        DebugPrint (("ERROR: Resetting the bus instead\n"));
        RaidAdapterResetBus (Unit->Adapter,
                             StorGetAddressPathId (Unit->Address));

        return ;
    }

    //
    // We cannot reset the logical unit at dispatch level because we need
    // to queue a synchronous request to the logical unit's device queue.
    // Therefore, queue a work item to do the reset for us. If we fail to
    // create a work-item, then fall back and do a full bus reset, because
    // we can do this synchronously at dispatch level.
    //
    // Note: if we add HwResetTarget and HwResetBus commands to the port
    // configuration information, then we could avoid having to queue
    // a work-item here.
    //

    WorkItem = IoAllocateWorkItem (Unit->DeviceObject);

    if (WorkItem != NULL) {
        IoQueueWorkItem (WorkItem,
                         RaidHierarchicalResetWorkRoutine,
                         CriticalWorkQueue,
                         WorkItem);
    } else {

        //
        // Failed to create a work-item, so fall back and reset the
        // entire bus.
        //

        RaidAdapterResetBus (Unit->Adapter,
                             StorGetAddressPathId (Unit->Address));
    }
}

NTSTATUS
RaidUnitHierarchicalReset(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Perform a hierarchical reset on the logical unit.

Arguments:

    Unit - Logical unit to reset.

Return Value:

    NTSTATUS code.

Environment:

    This function is in the reset path, and therefore may not be paged.

--*/
{
    NTSTATUS Status;

    PAGED_CODE();
    
    //
    // First, try to reset the logical unit.
    //
    
    Status = RaidUnitResetUnit (Unit);

    //
    // If that worked, we're done.
    //
    
    if (NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // Next, try to reset the target.
    //
    
    Status = RaidUnitResetTarget (Unit);

    //
    // That worked, we're done.
    //
    
    if (NT_SUCCESS (Status)) {
        return Status;
    }

    //
    // A less severe form of reset failed to work properly. Give up,
    // and just reset the bus here.
    //
    
    Status = RaidAdapterResetBus (Unit->Adapter,
                                  StorGetAddressPathId (Unit->Address));

    return Status;
}



LOGICAL
RaidUnitNotifyHardwareGone(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    This routine is invoked by the enumeration code when a logical unit
    goes away.

Arguments:

    Unit - Logical unit that went away.

Return Value:

    TRUE - If PnP should be notified of the removal.

    FALSE - If PnP does not need to be notified.

--*/
{
    NTSTATUS Status;
    LOGICAL ChangeDetected;
    KIRQL OldIrql;

    ChangeDetected = FALSE;
    
    if (Unit->Flags.Present) {
        Unit->Flags.Present = FALSE;
        OldIrql = KeRaiseIrqlToDpcLevel ();
        Status = RaidUnitCancelPendingRequestsAsync (Unit);
        KeLowerIrql (OldIrql);
    }

    if (Unit->Flags.Enumerated) {
        ChangeDetected = TRUE;
    }

    return ChangeDetected;
}


NTSTATUS
RaidUnitCancelPendingRequestsAsync(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Asynchronously remove all queued requests from the logical unit. 

Arguments:

    Unit - Logical unit to remove queued requests for.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PIO_WORKITEM WorkItem;
    
    WorkItem = IoAllocateWorkItem (Unit->DeviceObject);

    if (WorkItem != NULL) {

        //
        // Acquire a remove lock so we are not removed before this event
        // can fire.
        //
        
        RaUnitAcquireRemoveLock (Unit, NULL);
        
        IoQueueWorkItem (WorkItem,
                         RaidCancelRequestsWorkRoutine,
                         CriticalWorkQueue,
                         WorkItem);
        Status = STATUS_SUCCESS;
    } else {
        //
        // Low memory: we failed to allocate the work item, so perform
        // the operation(s) synchronously.
        //
        REVIEW();
        Status = RaidUnitCancelPendingRequests (Unit);
    }

    return Status;
}



NTSTATUS
RaidCancelRequestsWorkRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    Called from a work queue; this routine synchronously cancels all
    queued requests on a device queue.

Arguments:

    DeviceObject - Device object of queue to flush.

    Context - Context representing the work item.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS Status;
    PRAID_UNIT_EXTENSION Unit;
    PIO_WORKITEM WorkItem;
    KIRQL Irql;

    Unit = DeviceObject->DeviceExtension;
    WorkItem = (PIO_WORKITEM)Context;
    ASSERT_UNIT (Unit);
    ASSERT (WorkItem != NULL);

    Irql = KeRaiseIrqlToDpcLevel ();

    //
    // This should clear out the queue and return the already-setup failing
    // status.
    // 

    Status = RaidUnitCancelPendingRequests (Unit);

    //
    // Release the remove lock reference acquired before queuing the work
    // routine.
    //
    
    RaUnitReleaseRemoveLock (Unit, NULL);

    KeLowerIrql (Irql);

    IoFreeWorkItem (WorkItem);

    return Status;
}



NTSTATUS
RaidUnitCancelPendingRequests(
    IN PRAID_UNIT_EXTENSION Unit
    )
/*++

Routine Description:

    Synchronously cancel all pending requests and outstanding requests.

Arguments:

    Unit - Logical unit to cancel pending requests for.

Return Value:

    NTSTATUS code.

--*/
{
    PIRP Irp;
    PSCSI_REQUEST_BLOCK Srb;
    PVOID CompletionStatus;

    CompletionStatus = (PVOID) SRB_STATUS_NO_DEVICE;

    //
    // NOTE: We do NOT purge the outstanding queue. Instead, we allow these
    // to fail. Purging the outstanding queue is fraught with complexities
    // and race conditions. Instead, allow the requets to timeout, then
    // fail them when we retry.
    //

    //
    // Purge pending requets.
    //
    
    RaidPurgeIoQueue (&Unit->IoQueue,
                      RaidCancelIrp,
                      CompletionStatus);


    return STATUS_SUCCESS;
}



VOID
RaidUnitPauseTimerDpcRoutine(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context1,
    IN PVOID Context2
    )
/*++

Routine Description:

    This routine is called when a logical unit is un-paused.

Arguments:

    Dpc - The deferred procedure call this request is for.

    DeviceObject - The device object associated with the timer.

    Context1, Context2 - Unused.
    
Return Value:

    None.

--*/
{
    PRAID_UNIT_EXTENSION Unit;
    LOGICAL Resumed;

    VERIFY_DISPATCH_LEVEL();

    Unit = (PRAID_UNIT_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT_UNIT (Unit);

    //
    // Timeout has expired, resume the IO queue.
    //
    
    Resumed = RaidResumeUnitQueue (Unit);

    //
    // If our pause count has hit zero, resume the logical unit queue.
    //
    
    if (Resumed) {
        RaidUnitRestartQueue (Unit);
    }
}

VOID
RaidUnitBusy(
    IN PRAID_UNIT_EXTENSION Unit,
    IN ULONG RequestsToComplete
    )
/*++

Routine Description:

    Put a logical unit into the busy state. The logical unit remains
    busy until it has completed the number of requests specified by
    RequestsToComplete or when it's outstanding queue reaches zero.

Arguments:

    Unit - Supplies the logical unit to make busy.

    RequestsToComplete - Specifies the number of requests to complete.

Return Value:

    NTSTATUS code

--*/
{
    RaidBusyIoQueue (&Unit->IoQueue, RequestsToComplete);
}

VOID
RaidUnitReady(
    IN PRAID_UNIT_EXTENSION Unit
    )
{
    RaidReadyIoQueue (&Unit->IoQueue);
    RaidUnitRestartQueue (Unit);
}
