/*++
Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    Util.c

Abstract:

    Provide general utility functions for the driver, such as: ForwardIRPSynchronous, and
    ForwardIRPASynchronous...

Environment:

    kernel mode only

Notes:

--*/
#include "Filter.h"
#include "Device.h"
#include "Util.h"
#include "stdarg.h"
#include "stdio.h"
#include "classpnp.h"

#if DBG_WMI_TRACING
    //
    // for any file that has software tracing printouts, you must include a
    // header file <filename>.tmh
    // this file will be generated by the WPP processing phase
    //
    #include "Util.tmh"
#endif


#ifdef ALLOC_PRAGMA
    #pragma alloc_text (PAGE, DataVerFilter_ForwardIrpSyn)
    #pragma alloc_text (PAGE, GetDeviceDescriptor)
    #pragma alloc_text (PAGE, AcquirePassiveLevelLock)
    #pragma alloc_text (PAGE, ReleasePassiveLevelLock)
    #pragma alloc_text (PAGE, CallDriverSync)
#endif


/*
 *  Global list of all device contexts, used by debug extension
 */
LIST_ENTRY AllContextsList = {&AllContextsList, &AllContextsList};

    
/*++

Routine Description:

    Parsing the IRP_MJ_PNP's MN function code.

Arguments:

    Irp             - Supplies the I/O request packet.

Return Value:

    return the corresponding string if any.

--*/
char *
DbgGetPnPMNOpStr(
    IN PIRP Irp
    )
{
    char *               pszFuncCode     = NULL;
    PIO_STACK_LOCATION  irpStack        = IoGetCurrentIrpStackLocation(Irp);
    
    switch ( irpStack->MinorFunction )
    {
        #undef  MAKE_CASE
        #define MAKE_CASE( minorFunction )  case minorFunction: pszFuncCode = #minorFunction; break;
    
        MAKE_CASE(IRP_MN_START_DEVICE)
        MAKE_CASE(IRP_MN_QUERY_REMOVE_DEVICE)
        MAKE_CASE(IRP_MN_REMOVE_DEVICE)
        MAKE_CASE(IRP_MN_CANCEL_REMOVE_DEVICE)
        MAKE_CASE(IRP_MN_STOP_DEVICE)
        MAKE_CASE(IRP_MN_QUERY_STOP_DEVICE)
        MAKE_CASE(IRP_MN_CANCEL_STOP_DEVICE)
        MAKE_CASE(IRP_MN_QUERY_DEVICE_RELATIONS)
        MAKE_CASE(IRP_MN_QUERY_INTERFACE)
        MAKE_CASE(IRP_MN_QUERY_CAPABILITIES)
        MAKE_CASE(IRP_MN_QUERY_RESOURCES)
        MAKE_CASE(IRP_MN_QUERY_RESOURCE_REQUIREMENTS)
        MAKE_CASE(IRP_MN_QUERY_DEVICE_TEXT)
        MAKE_CASE(IRP_MN_FILTER_RESOURCE_REQUIREMENTS)
        MAKE_CASE(IRP_MN_READ_CONFIG)
        MAKE_CASE(IRP_MN_WRITE_CONFIG)
        MAKE_CASE(IRP_MN_EJECT)
        MAKE_CASE(IRP_MN_SET_LOCK)
        MAKE_CASE(IRP_MN_QUERY_ID)
        MAKE_CASE(IRP_MN_QUERY_PNP_DEVICE_STATE)
        MAKE_CASE(IRP_MN_QUERY_BUS_INFORMATION)
        MAKE_CASE(IRP_MN_DEVICE_USAGE_NOTIFICATION)
        MAKE_CASE(IRP_MN_SURPRISE_REMOVAL)
        default:
                    pszFuncCode = "IRP_MN_UNKNONW";
                    break;
    }

    return pszFuncCode;
}   



/*++

Routine Description:

    Display the current IRQL.

Arguments:

    N/A

Return Value:

    N/A

--*/
VOID DataVerFilter_DisplayIRQL()
{
    KIRQL   currentIRQL =   KeGetCurrentIrql();
    char*   pszFuncCode;

    switch ( currentIRQL )
    {
        MAKE_CASE( PASSIVE_LEVEL )
        MAKE_CASE( APC_LEVEL )
        MAKE_CASE( DISPATCH_LEVEL )
        default:
            pszFuncCode = "UNKNOWN";
            break;
    }

}


/*++

Routine Description:

    FilterDriver_CompleteRequest: complete a requestion.

Arguments:

    Irp             -   point to an IRP
    status          -   status to set
    info            -   information.

Return Value:

    NTSTATUS

--*/
NTSTATUS 
DataVerFilter_CompleteRequest(
    IN PIRP         Irp, 
    IN NTSTATUS     status, 
    IN ULONG        info
    )
{
    
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = info;
    
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

/*++

Routine Description:

  Send the IRP to the lower level driver. (for both Asyn and Syn)

Arguments:

    DeviceObject        -   device Object.
    Irp                 -   point to the IRP
    CompletionRountine  -   point to the completionRountine
    pContext            -   point to the user specified structure/data
    pEvent              -   if pEvent is not NULL, will wait on completion.
                            (Syn if pEvent != NULL)

Return Value:

    NTSTATUS

--*/

NTSTATUS
DataVerFilter_ForwardIrp(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp,
    IN PIO_COMPLETION_ROUTINE   CompletionRoutine OPTIONAL,
    IN PVOID                    pContext OPTIONAL,
    IN PVOID                    pEvent OPTIONAL
    )
{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS            status          = STATUS_SUCCESS;

    if ( CompletionRoutine == NULL )
    {
        IoSkipCurrentIrpStackLocation(Irp);
    }
    else
    {
        //
        // copy the irpstack for the next device
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        //
        // set a completion routine
        //

        IoSetCompletionRoutine(Irp, 
                               CompletionRoutine,
                               pContext,    //pEvent.
                               TRUE,        //InvokeOnSuccess
                               TRUE,        //InvokeOnError
                               TRUE         //InvokeOnCancel
                               );
    }

    status = IoCallDriver(deviceExtension->LowerDeviceObject, Irp);

    if (pEvent && (status == STATUS_PENDING)){
        KeWaitForSingleObject(pEvent, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;        
    }

    return status;

} 


/*++

Routine Description:

  Send the IRP to the lower level driver asychronously.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

NTSTATUS
DataVerFilter_ForwardIrpAsyn(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp,
    IN PIO_COMPLETION_ROUTINE   CompletionRoutine OPTIONAL,
    IN PVOID                    pContext OPTIONAL
    )
{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS            status          = STATUS_SUCCESS;

    return DataVerFilter_ForwardIrp( DeviceObject, 
                                     Irp, 
                                     CompletionRoutine, 
                                     pContext, 
                                     NULL );

}


/*++

Routine Description:

    Forwarded IRP completion routine. Set an event and return
    STATUS_MORE_PROCESSING_REQUIRED. Irp forwarder will wait on this
    event and then complete the irp after cleaning up.

Arguments:

    DeviceObject -  the device object of the WMI driver
    Irp          -  the WMI irp that was just completed
    pContext     -  PKEVENT that forwarder will wait on

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED

--*/
NTSTATUS
DataVerFilter_IrpSignalCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            pContext
    )
{
    PKEVENT pEvent = (PKEVENT) pContext;

    KeSetEvent(pEvent, IO_NO_INCREMENT, FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;

} 


/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp needs to be processed by the lower drivers
    prior to being processed by this one.

    a common completion routine will be used.
    
    The remove lock must be acquired before calling this routine.

Arguments:

    DeviceObject
    Irp
    
Return Value:

    NTSTATUS

--*/
NTSTATUS
DataVerFilter_ForwardIrpSyn(
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp    
    )
{
    PDEVICE_EXTENSION           deviceExtension;
    KEVENT                      event;
    NTSTATUS                    status  = STATUS_SUCCESS;

    PAGED_CODE();
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    return DataVerFilter_ForwardIrp(DeviceObject, 
                                    Irp, 
                                    DataVerFilter_IrpSignalCompletion, 
                                    &event, 
                                    &event);

} 


NTSTATUS GetDeviceDescriptor(PDEVICE_EXTENSION DeviceExtension, STORAGE_PROPERTY_ID PropertyId, OUT PVOID *DescHeader)
{
    PIRP irp;
    NTSTATUS status;

    PAGED_CODE();

    *DescHeader = NULL;

    irp = IoAllocateIrp(DeviceExtension->LowerDeviceObject->StackSize , FALSE);
    if (irp){
        STORAGE_PROPERTY_QUERY propQuery = {0};
        PIO_STACK_LOCATION nextIrpSp = IoGetNextIrpStackLocation(irp);

        ASSERT(sizeof(STORAGE_PROPERTY_QUERY) >= sizeof(STORAGE_DESCRIPTOR_HEADER));

        //
        // Send down the request with a minimal buffer to obtain the size
        //
        nextIrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        nextIrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_STORAGE_QUERY_PROPERTY;
        nextIrpSp->Parameters.DeviceIoControl.InputBufferLength  = sizeof(STORAGE_PROPERTY_QUERY);
        nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = sizeof(STORAGE_DESCRIPTOR_HEADER);

        propQuery.PropertyId = PropertyId;
        propQuery.QueryType  = PropertyStandardQuery;
        irp->AssociatedIrp.SystemBuffer = &propQuery;

        status = CallDriverSync(DeviceExtension->LowerDeviceObject, irp);

        if (((PSTORAGE_DESCRIPTOR_HEADER)&propQuery)->Size == 0)
        {
            status = STATUS_UNSUCCESSFUL;
        }

        if (NT_SUCCESS(status))
        {
            PSTORAGE_DESCRIPTOR_HEADER descHeader;

            descHeader = AllocPool(DeviceExtension, NonPagedPool, ((PSTORAGE_DESCRIPTOR_HEADER)&propQuery)->Size, FALSE);
            if (descHeader){
                IoReuseIrp(irp, STATUS_NOT_SUPPORTED);

                ASSERT(((PSTORAGE_DESCRIPTOR_HEADER)&propQuery)->Size >= sizeof(STORAGE_PROPERTY_QUERY));

                //
                // Send down the request with a buffer of the appropriate size
                //
                nextIrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
                nextIrpSp->Parameters.DeviceIoControl.IoControlCode      = IOCTL_STORAGE_QUERY_PROPERTY;
                nextIrpSp->Parameters.DeviceIoControl.InputBufferLength  = sizeof(STORAGE_PROPERTY_QUERY);
                nextIrpSp->Parameters.DeviceIoControl.OutputBufferLength = ((PSTORAGE_DESCRIPTOR_HEADER)&propQuery)->Size;

                ((PSTORAGE_PROPERTY_QUERY)descHeader)->PropertyId = PropertyId;
                ((PSTORAGE_PROPERTY_QUERY)descHeader)->QueryType  = PropertyStandardQuery;
                irp->AssociatedIrp.SystemBuffer = descHeader;

                status = CallDriverSync(DeviceExtension->LowerDeviceObject, irp);

                if (descHeader->Size == 0)
                {
                    status = STATUS_UNSUCCESSFUL;
                }

                if (NT_SUCCESS(status))
                {
                    *DescHeader = descHeader;
                }
                else
                {
                    FreePool(DeviceExtension, descHeader, NonPagedPool);
                }
            }
            else
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        IoFreeIrp(irp);
    }
    else
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}


VOID AcquirePassiveLevelLock(PDEVICE_EXTENSION DeviceExtension)
{
    PAGED_CODE();
    KeWaitForSingleObject(&DeviceExtension->SyncEvent, Executive, KernelMode, FALSE, NULL);
    DeviceExtension->DbgSyncEventHolderThread = (PVOID)KeGetCurrentThread();
}


VOID ReleasePassiveLevelLock(PDEVICE_EXTENSION DeviceExtension)
{
    PAGED_CODE();
    DeviceExtension->DbgSyncEventHolderThread = NULL;
    KeSetEvent(&DeviceExtension->SyncEvent, IO_NO_INCREMENT, FALSE);
}


NTSTATUS CallDriverSync(IN PDEVICE_OBJECT TargetDevObj, IN OUT PIRP Irp)
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(Irp, CallDriverSyncCompletion, &event, TRUE, TRUE, TRUE);

    status = IoCallDriver(TargetDevObj, Irp);

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    status = Irp->IoStatus.Status;

    return status;
}


NTSTATUS CallDriverSyncCompletion(IN PDEVICE_OBJECT DevObjOrNULL, IN PIRP Irp, IN PVOID Context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    DevObjOrNULL -
            Usually, this is this driver's device object.
             However, if this driver created the IRP,
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    Irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync.


Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = (PKEVENT)Context;

    ASSERT(Irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



PVOID 
AllocPool (
    PDEVICE_EXTENSION DeviceExtension, 
    POOL_TYPE PoolType, 
    ULONG NumBytes,
    BOOLEAN SyncEventHeld
    )
/*++

    Routine Description:

        Pool allocation wrapper with memory intialization.
        For nonpaged pool allocation failure, retries after unlocking some pool.

        Must be called with SPINLOCK NOT HELD, because it may need to unlock some internal pool.
        
    Arguments:

        DeviceExtension -       device extension
        PoolType -                  indicates type of pool (PagedPool | NonPagedPool)
        NumBytes -                number of bytes requested
        SyncEventHeld -         TRUE iff SyncEvent is held by current thread
        
    Return value:

        if successful, pointer to allocated pool; else NULL.
        
--*/
{
    static BOOLEAN complainedAboutNonPagedAllocFailure = FALSE;
    static BOOLEAN complainedAboutPagedAllocFailure = FALSE;
    PVOID newBuf;
    
    switch (PoolType){
    
        case PagedPool:
            newBuf = ExAllocatePoolWithTag(PagedPool, NumBytes, DATA_VER_TAG);
            if (newBuf){
                RtlZeroMemory(newBuf, NumBytes);
                InterlockedIncrement((PULONG)&DeviceExtension->DbgNumPagedAllocs);
            }
            else {
                if (!complainedAboutPagedAllocFailure){
                    complainedAboutPagedAllocFailure = TRUE;
                    DBGWARN(("Paged pool allocation failed"));
                }        
                DeviceExtension->DbgNumAllocationFailures++;
            }
            break;
            
        case NonPagedPool:
            newBuf = ExAllocatePoolWithTag(NonPagedPool, NumBytes, DATA_VER_TAG);
            if (!newBuf){
                /* 
                 *  If possible, unlock some memory and try again
                 */
                if (KeGetCurrentIrql() < DISPATCH_LEVEL){
                    if (!SyncEventHeld){
                        AcquirePassiveLevelLock(DeviceExtension);
                    }      
                    UnlockLRUChecksumArray(DeviceExtension);
                    if (!SyncEventHeld){
                        ReleasePassiveLevelLock(DeviceExtension);
                    }        
                    newBuf = ExAllocatePoolWithTag(NonPagedPool, NumBytes, DATA_VER_TAG);
                }        
            }
            if (newBuf){
                RtlZeroMemory(newBuf, NumBytes);
                InterlockedIncrement((PULONG)&DeviceExtension->DbgNumNonPagedAllocs);
            }
            else {
                if (!complainedAboutNonPagedAllocFailure){
                    complainedAboutNonPagedAllocFailure = TRUE;
                    DBGWARN(("NonPaged pool allocation failed"));
                }       
                DeviceExtension->DbgNumAllocationFailures++;
            }
            break;
            
        default:
            ASSERT(0);
            newBuf = NULL;
            break;
    }
    
    return newBuf;
}


VOID FreePool(PDEVICE_EXTENSION DeviceExtension, PVOID Buf, POOL_TYPE PoolType)
{
    switch (PoolType){
    
        case PagedPool:
            ASSERT(DeviceExtension->DbgNumPagedAllocs > 0);
            InterlockedDecrement((PULONG)&DeviceExtension->DbgNumPagedAllocs);
            ExFreePool(Buf);
            break;

        case NonPagedPool:
            ASSERT(DeviceExtension->DbgNumNonPagedAllocs > 0);
            InterlockedDecrement((PULONG)&DeviceExtension->DbgNumNonPagedAllocs);
            ExFreePool(Buf);
            break;

        default:
            ASSERT(0);
            break;
    }            
}

